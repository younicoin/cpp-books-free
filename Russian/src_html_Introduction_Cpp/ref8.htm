<htm>
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Бьярн Страустрап. Введение в язык Си++, Описания</title>
</head>

<body bgcolor="#FFF5EE" link="#FF0000" vlink="#A52A2A"
alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h2 align="center"><a name="ref8">8. Описания </a></h2>

<p><a name="ref8">Описания используются
для определения интерпретации,
даваемой каждому идентификатору;
они не обязательно резервируют
память, связанную с
идентификатором. Описания имеют
вид: </a></p>

<p><a name="ref8">описание: </a></p>

<pre><a name="ref8">
      спецификаторы_описания opt список_описателей opt ;
      описание_имени
      asm_описание
</a></pre>

<p><a name="ref8"><br>
Описатели в списке_описателей
содержат идентификаторы,
подлежащие описанию.
Спецификаторы_описания могут быть
опущены только в определениях
внешних функций (</a><a
href="ref9_18.htm#ref9_18.10">#10</a>) или в
описаниях внешних функций. Список
описателей может быть пустым
только при описании класса (<a
href="#ref8.5">#8.5</a>) или перечисления (<a
href="#ref8.10">#8.10</a>), то есть, когда
спецификаторы_описания - это
class_спецификатор или
enum_спецификатор. Описания имен
описываются в #8.8; описания asm
описаны в <a href="#ref8.11">#8.11.</a> </p>

<pre>
  спецификатор_описания:
      sc_спецификатор
      спецификатор_типа
      фнк_спецификатор
      friend
      typedef

  спецификаторы_описания:
      спецификатор_описания спецификатор_описания opt
</pre>

<p><br>
Список должен быть внутренне
непротиворечив в описываемом ниже
смысле. </p>

<h3 align="center"><a name="ref8.1">8.1
Спецификаторы класса памяти </a></h3>

<p><a name="ref8.1">Спецификаторы &quot;класса
памяти&quot; (sc-спецификатор) это: </a></p>

<pre><a name="ref8.1">
  sc-спецификатор:
      auto
      static
      extern
      register
</a></pre>

<p><a name="ref8.1"><br>
Описания, использующие
спецификаторы auto, static и register также
служат определениями тем, что они
вызывают резервирование
соответствующего объема памяти.
Если описание extern не является
определением (</a><a href="ref1_7.htm#ref1_7.4.2">#4.2</a>),
то где-то еще должно быть
определение для данных
идентификаторов. <br>
Описание register лучше всего
представить как описание auto
(автоматический) с подсказкой
компилятору, что описанные
переменные усиленно используются.
Подсказка может быть
проигнорирована. К ним не может
применяться операция получения
адреса &amp;. <br>
Спецификаторы auto или register могут
применяться только к именам,
описанным в блоке, или к формальным
параметрам. Внутри блока не может
быть описаний ни статических
функций, ни статических формальных
параметров. <br>
В описании может быть задан
максимум один sc_спецификатор. Если
в описании отсутствует
sc_спецификатор, то класс памяти
принимается автоматическим внутри
функции и статическим вне.
Исключение: функции не могут быть
автоматическими. <br>
Спецификаторы static и extern могут
использоваться только для имен
объектов и функций. <br>
Некоторые спецификаторы могут
использоваться только в описаниях
функций: </p>

<pre>
  фнк-спецификатор:
      overload
      inline
      virtual
</pre>

<p><br>
Спецификатор перегрузки overload
делает возможным использование
одного имени для обозначения
нескольких функций; см. <a href="#ref8.9">#8.9.</a>
<br>
Спецификатор inline является только
подсказкой компилятору, не влияет
на смысл программы и может быть
проигнорирован. Он используется,
чтобы указать на то, что при вызове
функции inline- подстановка тела
функции предпочтительнее обычной
реализации вызова функции. Функция
(<a href="#ref8.5.2">#8.5.2</a> и <a href="#ref8.5.10">#8.5.10</a>),
определенная внутри описания
класса, является inline по умолчанию. <br>
Спецификатор virtual может
использоваться только в описаниях
членов класса; см. <a href="#ref8.5.4">#8.5.4.</a> <br>
Спецификатор friend используется для
отмены правил скрытия имени для
членов класса и может
использоваться только внутри
описаний классов; см. <a href="#ref8.5.9">#8.5.9.</a>
<br>
С помощью спецификатора typedef
вводится имя для типа; см. <a href="#ref8.8">#8.8.</a>
</p>

<h3 align="center"><a name="ref8.2">8.2
Спецификаторы Типа </a></h3>

<p><a name="ref8.2">Спецификаторами типов
(спецификатор_типа) являются: </a></p>

<pre><a name="ref8.2">
  спецификатор_типа:
      простое_имя_типа
      class_спецификатор
      enum-спецификатор
      сложный_спецификатор_типа
      const
</a></pre>

<p><a name="ref8.2"><br>
Слово const можно добавлять к любому
допустимому спецификатору_типа. В
остальных случаях в описании может
быть дано не более одного
спецификатора_типа. Объект типа const
не является lvalue. Если в описании
опущен спецификатор типа, он
принимается int. </a></p>

<pre><a name="ref8.2">
  простое_имя_типа:
      char
      short
      int
      long
      unsigned
      float
      double
      const
      void
</a></pre>

<p><a name="ref8.2"><br>
Слова long, short и unsigned можно
рассматривать как прилагательные.
Они могут применяться к типу int;
unsigned может также применяться к
типам char, short и long. <br>
Спецификаторы класса и
перечисления обсуждаются в </a><a
href="#ref8.5">#8.5</a> и <a href="#ref8.10">#8.10</a>
соответственно. </p>

<pre>
  сложный_спецификатор_типа:
      ключ typedef-имя
      ключ идентификатор

  ключ:
      class
      struct
      union
      enum
</pre>

<p><br>
Сложный спецификатор типа можно
использовать для ссылки на имя
класса или перечисления там, где
имя может быть скрыто локальным
именем. Например: </p>

<pre>
  class x { ... };

  void f(int x)
  {
      class x a;
      // ...
  }
</pre>

<p><br>
Если имя класса или перечисления
ранее описано не было,
сложный_спецификатор_типа работает
как описание_имени; см. <a href="#ref8.8">#8.8.</a>
</p>

<h3 align="center"><a name="ref8.3">8.3 Описатели</a></h3>

<p><a name="ref8.3">Список_описателей,
появляющийся в описании, есть
разделенная запятыми
последовательность описателей,
каждый из которых может иметь
инициализатор. </a></p>

<pre><a name="ref8.3">
  список_описателей:
      иниц_описатель
      иниц_описатель  ,  список_описателей
      иниц_описатель:
      описатель  инициализатор opt
</a></pre>

<p><a name="ref8.3"><br>
Инициализаторы обсуждаются в </a><a
href="#ref8.6">#8.6.</a> Спецификатор в
описании указывает тип и класс
памяти объектов, к которым
относятся описатели. Описатели
имеют синтаксис: </p>

<pre>
  описатель:
      оп_имя
      ( описатель )
      * const opt  описатель
      &amp; const opt  описатель
      описатель   ( список_описаний_параметров )
      описатель     [ константное_выражение opt ]

  оп-имя:
      простое_оп_имя
      typedef-имя  ::  простое_оп_имя

  простое_оп_имя:
      идентификатор
      typedef-имя
      ~  typedef-имя
      имя_функции_операции
      имя_функции_преобразования
</pre>

<p><br>
Группировка та же, что и в
выражениях. </p>

<h3 align="center"><a name="ref8.4">8.4 Смысл
описателей</a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref8.4"></a>&nbsp;</td>
        <td><a href="#ref8.4.1">8.4.1 Примеры </a></td>
    </tr>
</table>

<p>Каждый описатель считается
утверждением того, что если в
выражении возникает конструкция,
имеющая ту же форму, что и
описатель, то она дает объект
указанного типа и класса памяти.
Каждый описатель содержит ровно
одно оп_имя; оно определяет
описываемый идентификатор. За
исключением описаний некоторых
специальных функций (см. <a href="#ref8.5.2">#8.5.2</a>)
, оп_имя будет простым
идентификатором. <br>
Если в качестве описателя
возникает ничем не снабженный
идентификатор, то он имеет тип,
указанный спецификатором,
возглавляющим описание. <br>
Описатель в скобках эквивалентен
описателю без скобок, но связку
сложных описателей скобки могут
изменять. <br>
Теперь представим себе описание </p>

<pre>
  T D1
</pre>

<p><br>
где T - спецификатор типа (как int и
т.д.), а D1 - описатель. Допустим, что
это описание заставляет
идентификатор иметь тип &quot;... T&quot;,
где &quot;...&quot; пусто, если
идентификатор D1 есть просто
обычный идентификатор (так что тип x
в &quot;int x&quot; есть просто int). Тогда,
если D1 имеет вид </p>

<pre>
  *D
</pre>

<p><br>
то тип содержащегося
идентификатора есть &quot;...
указатель на T.&quot; <br>
Если D1 имеет вид </p>

<pre>
  * const D
</pre>

<p><br>
то тип содержащегося
идентификатора есть &quot;...
константный указатель на T&quot;, то
есть, того же типа, что и *D, но не lvalue.
<br>
Если D1 имеет вид </p>

<pre>
  &amp;D
</pre>

<p><br>
или </p>

<pre>
  &amp; const D
</pre>

<p><br>
то тип содержащегося
идентификатора есть &quot;... ссылка на
T.&quot; Поскольку ссылка по
определению не может быть lvalue,
использование const излишне.
Невозможно иметь ссылку на void
(void&amp;). <br>
Если D1 имеет вид </p>

<pre>
  D (список_описаний_параметров)
</pre>

<p><br>
то содержащийся идентификатор
имеет тип &quot;... функция,
принимающая параметр типа
список_описаний_параметров и
возвращающая T.&quot; </p>

<pre>
  список_описаний_параметров:
      список_описаний_парам opt ... opt

  список_описаний_парам:
      список_описаний_парам  ,  описание_параметра
      описание_параметра

  описание_параметра:
      спецификаторы_описания  описатель
      спецификаторы_описания  описатель  = выражение
      спецификаторы_описания  абстракт_описатель
      спецификаторы_описания  абстракт_описатель  =  выражение
</pre>

<p><br>
Если список_описаний_параметров
заканчивается многоточием, то о
числе параметров известно лишь, что
оно равно или больше числа
специфицированных типов
параметров; если он пуст, то функция
не получает ни одного параметра.
Все описания для функции должны
согласовываться и в типе
возвращаемого значения, а также в
числе и типе параметров. <br>
Список_описаний_параметров
используется для проверки и
преобразования фактических
параметров и для контроля
присваивания указателю на функцию.
Если в описании параметра
специфицировано выражение, то это
выражение используется как
параметр по умолчанию. Параметры по
умолчанию будут использоваться в
вызовах, где опущены стоящие в
хвосте параметры. Параметр по
умолчанию не может
переопределяться более поздними
описаниями. Однако, описание может
добавлять параметры по умолчанию,
не заданные в предыдущих описаниях.
<br>
Идентификатор может по желанию
быть задан как имя параметра. Если
он присутствует в описании функции,
его использовать нельзя, поскольку
он сразу выходит из области
видимости. Если он присутствует в
определении функции (<a
href="ref9_18.htm#ref9_18.10">#10</a>), то он именует
формальный параметр. <br>
Если D1 имеет вид </p>

<pre>
  D[ константное_выражение]
</pre>

<p><br>
или </p>

<pre>
  D[]
</pre>

<p><br>
то тип содержащегося
идентификатора есть &quot;... массив
объектов типа T&quot;. В первом случае
константное_выражение есть
выражение, значение которого может
быть определено во время
компиляции, и тип которого int.
(Константные выражения определены
в <a href="ref9_18.htm#ref9_18.12">#12.</a>) Если
подряд идут несколько спецификаций
&quot;массив из&quot;, то создается
многомерный массив; константное
выражение, определяющее границы
массива, может быть опущено только
для первого члена
последовательности. Этот пропуск
полезен, когда массив является
внешним, и настоящее определение,
которое резервирует память,
находится в другом месте. Первое
константное выражение может также
быть опущено, когда за описателем
следует инициализация. В этом
случае используется размер,
вычисленный исходя из числа
начальных элементов. <br>
Массив может быть построен из
одного из основных типов, из
указателей, из структуры или
объединения или из другого массива
(для получения многомерного
массива). <br>
Не все возможности, которые
позволяет приведенный выше
синтаксис, допустимы. Ограничения
следующие: функция не может
возвращать массив или функцию, хотя
она может возвращать указатели на
эти объекты; не существует массивов
функций, хотя могут быть массивы
указателей на функции. </p>

<h4 align="center"><a name="ref8.4.1">8.4.1 Примеры </a></h4>

<p><a name="ref8.4.1">В качестве примера,
описание </a></p>

<pre><a name="ref8.4.1">
  int i;
  int *ip;
  int f ();
  int *fip ();
  int (*pfi) ();
</a></pre>

<p><a name="ref8.4.1"><br>
описывает целое i, указатель ip на
целое, функцию f, возвращающую
целое, функцию fip , возвращающую
указатель на целое, и указатель pfi
на функцию, возвращающую целое.
Особенно полезно сравнить
последние две. Цепочка *fip() есть
*(fip()), как предполагается в
описании, и та же конструкция
требуется в выражении, вызов
функции fip, и затем косвенное
использование результата через
(указатель) для получения целого. В
описателе (*pfi)() внешние скобки
необходимы, поскольку они также
входят в выражение, для указания
того, что функция получается
косвенно через указатель на
функцию, которая затем вызывается;
это возвращает целое. Функции f и fip
описаны как не получающие
параметров, и fip как указывающая на
функцию, не получающую параметров. <br>
Описание </a></p>

<pre><a name="ref8.4.1">
  const a = 10, *pc = &amp;a, *const cpc = pc;
  int b, *const cp = &amp;b
</a></pre>

<p><a name="ref8.4.1"><br>
описывает a: целую константу, pc:
указатель на целую константу, cpc:
константный указатель на целую
константу, b: целое и cp: константный
указатель на целое. Значения a, cpc и cp
не могут быть изменены после
инициализации. Значение pc может
быть изменено, как и объект,
указываемый cp. Примеры
недопустимых выражений : </a></p>

<pre><a name="ref8.4.1">
  a = 1;
  a++;
  *pc = 2;
  cp = &amp;a
  cpc++;
</a></pre>

<p><a name="ref8.4.1"><br>
Примеры допустимых выражений : </a></p>

<pre><a name="ref8.4.1">
  b = a;
  *cp = a;
  pc++;
  pc = cpc;
</a></pre>

<p><a name="ref8.4.1"><br>
Описание </a></p>

<pre><a name="ref8.4.1">
  fseek (FILE*,long,int);
</a></pre>

<p><a name="ref8.4.1"><br>
описывает функцию, получающую три
параметра специальных типов.
Поскольку тип возвращаемого
значения не определен, принимается,
что он int (</a><a href="#ref8.2">#8.2</a>).
Описание </p>

<pre>
  point (int = 0,int = 0);
</pre>

<p><br>
описывает функцию, которая может
быть вызвана без параметров, с
одним или двумя параметрами типа int.
Например </p>

<pre>
  point (1,2);
  point (1)             /* имеет смысл point (1,0); */
  point ()              /* имеет смысл point (0,0); */
</pre>

<p><br>
Описание </p>

<pre>
  printf (char* ... );
</pre>

<p><br>
описывает функцию, которая может
быть вызываться с различными
числом и типами параметров.
Например </p>

<pre>
  printf (&quot;hello, world&quot;);
  printf (&quot;a=%d b=%d&quot;,a,b);
  printf (&quot;string=%s&quot;,st);
</pre>

<p><br>
Однако, она всегда должна иметь
своим первым параметром char*. <br>
В качестве другого примера, </p>

<pre>
  float fa[17], *afp[17];
</pre>

<p><br>
описывает массив чисел с плавающей
точкой и массив указателей на числа
с плавающей точкой. И, наконец, </p>

<pre>
  static int x3d[3][5][7];
</pre>

<p><br>
описывает массив целых, размером
3x6x7. Совсем подробно: x3d является
массивом из трех элементов; каждый
из элементов является массивом из
пяти элементов; каждый из последних
элементов является массивом из
семи целых. Появление каждое из
выражений x3d, x3d[i], x3d[i][j], x3d[i][j][k]
может быть приемлемо. Первые три
имеют тип &quot;массив&quot;, последний
имеет тип int. </p>

<h3 align="center"><a name="ref8.5">8.5 Описания
классов </a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref8.5"></a>&nbsp;</td>
        <td><a href="#ref8.5.1">8.5.1 Статические
        члены </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.2">8.5.2 Функции члены </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.3">8.5.3 Производные
        классы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.4">8.5.4 Виртуальные
        функции </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.5">8.5.5 Конструкторы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.6">8.5.6
        Преобразования </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.7">8.5.7 Деструкторы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.8">8.5.8 Видимость имен
        членов </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.9">8.5.9 Друзья (friends) </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.10">8.5.10 Функция
        операция </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.11">8.5.11 Структуры </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.12">8.5.12 Объединения </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.13">8.5.13 Поля бит </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.5.14">8.5.14 Вложенные
        классы </a></td>
    </tr>
</table>

<p>Класс специфицирует тип. Его имя
становится typedef-имя (см. <a href="#ref8.8">#8.8</a>),
которое может быть использовано
даже внутри самого спецификатора
класса. Объекты класса состоят из
последовательности членов. </p>

<pre>
     спецификатор_класса:
          заголовок_класса     {      список_членов      opt      }
          заголовок_класса         {  список_членов  opt  public  :
     список_членов                      opt                       }

     заголовок_класса:
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     агрег:
          class
          struct
          union
</pre>

<p><br>
Структура является классом, все
члены которого общие; см. <a href="#ref8.5.8">#8.5.8.</a>
Объединение является классом,
содержащим в каждый момент только
один член; см. <a href="#ref8.5.12">#8.5.12.</a>
Список членов может описывать
члены вида: данные, функция, класс,
определение типа, перечисление и
поле. Поля обсуждаются в <a href="#ref8.5.13">#8.5.13.</a>
Список членов может также
содержать описания, регулирующие
видимость имен членов; см. <a
href="#ref8.5.8">#8.5.8.</a> </p>

<pre>
     список_членов:
          описание_члена  список_членов opt
     описание_члена:
          спецификаторы_описания        opt        описатель_члена;
     описатель_члена:
          описатель                         идентификатор   opt   :
     константное_выражение
</pre>

<p><br>
Члены, являющиеся классовыми
объектами, должны быть объектами
предварительно полностью
описанных классов. В частности,
класс cl не может содержать объект
класса cl, но он может содержать
указатель на объект класса cl. <br>
Имена объектов в различных классах
не конфликтуют между собой и с
обычными переменными. <br>
Вот простой пример описания
структуры: </p>

<pre>
  struct tnode
      {
        char tword[20];
        int count;
        tnode *left;
        tnode *right;
      };
</pre>

<p><br>
содержащей массив из 20 символов,
целое и два указателя на такие же
структуры. Если было дано такое
описание, то описание </p>

<pre>
  tnode s, *sp
</pre>

<p><br>
описывает s как структуру данного
сорта и sp как указатель на
структуру данного сорта. При
наличии этих описаний выражение </p>

<pre>
  sp-&gt;count
</pre>

<p><br>
ссылается на поле count структуры, на
которую указывает sp; </p>

<pre>
  s.left
</pre>

<p><br>
ссылается на указатель левого
поддерева структуры s; а </p>

<pre>
   s.right-&gt;tword[0]
</pre>

<p><br>
ссылается на первый символ члена
tword правого поддерева структуры s. </p>

<h4 align="center"><a name="ref8.5.1">8.5.1
Статические члены </a></h4>

<p><a name="ref8.5.1">Член-данные класса
может быть static; члены-функции не
могут. Члены не могут быть auto, register
или extern. Есть единственная копия
статического члена, совместно
используемая всеми членами класса
в программе. На статический член mem
класса cl можно ссылаться cl:mem, то
есть без ссылки на объект. Он
существует, даже если не было
создано ни одного объекта класса cl. </a></p>

<h4 align="center"><a name="ref8.5.2">8.5.2 Функции
члены </a></h4>

<p><a name="ref8.5.2">Функция, описанная как
член, (без спецификатора friend (</a><a
href="#ref8.5.9">#8.5.9</a>)) называется
функцией членом и вызывается с
помощью синтаксиса члена класса (<a
href="ref1_7.htm#ref1_7.7.1">#7.1</a>). Например: </p>

<pre>
  struct tnode
    {
      char tword[20];
      int count;
      tnode *left;
      tnode *right;
      void set (char* w,tnode* l,tnode* r);
    };

  tnode n1, n2;

  n1.set (&quot;asdf&quot;,&amp;n2,0);
  n2.set (&quot;ghjk&quot;,0,0);
</pre>

<p><br>
Определение функции члена
рассматривается как находящееся в
области видимости ее класса. Это
значит, что она может
непосредственно использовать
имена ее класса. Если определение
функции члена находится вне
описания класса, то имя функции
члена должно быть уточнено именем
класса с помощью записи </p>

<pre>
     typedef-имя . простое_оп_имя
</pre>

<p><br>
см. 3.3. Определения функций
обсуждаются в <a href="ref9_18.htm#ref9_18.10.1">#10.1.
Например: </a></p>

<pre><a href="ref9_18.htm#ref9_18.10.1">
  void tnode.set (char* w,tnode* l,tnode* r)
    {
      count = strlen (w);
      if (sizeof (tword) <= count) error ("tnode string too long"); strcpy (tword,w); left="l;" right="r;" } </PRE>

  Имя  функции  tnode.set  определяет  то,  что  множество  функций
является членом  класса tnode.  Это  позволяет  использовать  имена
членов word,  count, left  и  right.  В  функции  члене  имя  члена
ссылается на  объект, для  которого была  вызвана функция.  Так,  в
вызове  n1.set(...)   tword  ссылается  на  n1.tword,  а  в  вызове
n2.set(...)     он  ссылается   на   n2.tword.   В   этом   примере
предполагается, что функции strlen, error и strcpy описаны где-то в
другом месте как внешние функции (см. #10.1</a>).

  В члене  функции ключевое  слово this  указывает на  объект,  для
которого вызвана  функция. Типом  this в  функции, которая является
членом класса  cl, является cl*. Если mem - член класса cl,то mem и
this-&gt;mem -  синонимы в  функции члене  класса cl  (если mem не был
использован в  качестве имени  локальной переменной в промежуточной
области видимости).

  Функция член  может быть  определена (<a
href="ref9_18.htm#ref9_18.10.1">#10.1</a>)  в описании  класса. Помещение определения  функции члена  в  описание  класса  является
кратким видом  записи  описания  ее  в  описании  класса  и  затем
определения ее  как inline  (<a href="#ref8.1">#8.1</a>)  сразу  после  описания  класса.
Например:
</pre>

<pre>
  int b;
  struct x
    {
      int f () { return b; }
      int f () { return b; }
      int b;
    };
</pre>

<pre>
 означает
</pre>

<pre>
  int b;
  struct x
    {
      int f ();
      int b;
    };
  inline x.f () { return b; }
</pre>

<pre>
  Для функций  членов не нужно  использование спецификатора
overload (<a href="#ref8.2">#8.2</a>): если имя описывается как означающее несколько имен в классе, то оно перегружено (см. <a
href="#ref8.9">#8.9</a>).

  Применение операции получения адреса к функциям членам допустимо.
Тип параметра  результирующей функции  указатель на  есть (...), то
есть,  неизвестен   (<a href="#ref8.4">#8.4</a>).     Любое  использование  его  является
зависимым от  реализации, поскольку  способ инициализации указателя
для вызова функции члена не определен.
<a name="ref8.5.3">
</a></pre>

<h4 align="center"><a name="ref8.5.3">8.5.3
Производные классы</a></h4>

<p><a name="ref8.5.3">В конструкции </a></p>

<pre><a name="ref8.5.3">
     агрег идентификатор:public opt typedef-имя
</a></pre>

<pre><a name="ref8.5.3">
  typedef-имя  должно  означать  ранее  описанный  класс,  называемый
базовым классом  для класса,  подлежащего описанию.  Говорится, что
последний выводится  из предшествующего.  На члены  базового класса
можно ссылаться,  как если бы они были членами производного класса,
за  исключением   тех  случаев,   когда  имя  базового  члена  было
переопределено в  производном классе;  в этом  случае для ссылки на
скрытое имя  может использоваться такая запись (</a><a
href="ref1_7.htm#ref1_7.7.1">#7.1</a>): 
</pre>

<pre>
     typedef-имя :: идентификатор
</pre>

<pre>
    Например:
</pre>

<pre>
  struct base
    {
      int a;
      int b;
    };

  struct derived : public base
    {
      int b;
      int c;
    };

  derived d;

  d.a = 1;
  d.base::b = 2;
  d.b = 3;
  d.c = 4;
</pre>

<pre>
осуществляет присваивание четырем членам d.

  Производный тип сам может использоваться как базовый.
<a name="ref8.5.4">
</a></pre>

<h4 align="center"><a name="ref8.5.4">8.5.4
Виртуальные функции </a></h4>

<p><a name="ref8.5.4">Если базовый класс base
содержит (виртуальную) virtual (</a><a
href="#ref8.1">#8.1</a>) функцию vf, а
производный класс derived также
содержит функцию vf, то вызов vf для
объекта класса derived вызывает derived::vf.
Например: </p>

<pre>
  struct base
    {
      virtual void vf ();
      void f ();
    };

   struct derived : public base
    {
      void vf ();
      void f ();
    };

  derived d;
  base* bp = &amp;d

  bp-&gt;vf ();
  bp-&gt;f ();
</pre>

<pre>
  Вызовы вызывают,  соответственно,    derived::vf  и  base::f  для
объекта класса  derived,  именованного  d.  Так  что  интерпретация
вызова виртуальной  функции зависит  от типа  объекта, для которого
она вызвана,  в то  время как  интерпретация  вызова  невиртуальной
функции зависит только от типа указателя, обозначающего объект.

  Из  этого  следует,  что  тип  объектов  классов  с  виртуальными
функциями и  объектов классов,  выведенных из  таких классов, могут
быть определены во время выполнения.

Если производный  класс имеет  член с  тем же  именем,  что  и  у
виртуальной функции  в базовом  классе, то  оба члена  должны иметь
одинаковый тип.  Виртуальная функция  не может быть другом (friend)
(<a href="#ref8.5.9">#8.5.9</a>). Функция  f в  классе, выведенном из класса, который имеет виртуальную  функцию   f,  сама  рассматривается  как  виртуальная.
Виртуальная  функция  в  базовом  классе  должна  быть  определена.
Виртуальная функция,  которая была  определена в базовом классе, не
нуждается  в  определении  в  производном  классе.  В  этом  случае
функция, определенная  для базового  класса, используется  во  всех
вызовах.
<a name="ref8.5.5">
</a></pre>

<h4 align="center"><a name="ref8.5.5">8.5.5
Конструкторы</a></h4>

<p><a name="ref8.5.5">Член функция с именем,
совпадающим с именем ее класса,
называется конструктором.
Конструктор не имеет типа
возвращаемого значения; он
используется для конструирования
значений с типом его класса. С
помощью конструктора можно
создавать новые объекты его типа,
используя синтаксис </a></p>

<pre><a name="ref8.5.5">
     typedef-имя ( список_параметров opt )
</a></pre>

<pre><a name="ref8.5.5">
    Например,
</a></pre>

<pre><a name="ref8.5.5">
  complex zz = complex (1,2.3);

  cprint (complex (7.8,1.2));
</a></pre>

<pre><a name="ref8.5.5">
  Объекты,  созданные   таким  образом,   не  имеют   имени   (если
конструктор не  использован как  инициализатор, как  это было  с zz
выше), и  их время  жизни ограничено  областью видимости, в которой
они созданы.  Они не  могут рассматриваться  как константы их типа.
Если класс  имеет конструктор, то он вызывается для каждого объекта
этого класса перед тем, как этот объект будет как-либо использован;
см. </a><a href="#ref8.6">#8.6.</a>

  Конструктор может быть overload, но не virtual или friend.

  Если класс  имеет базовый  класс  с конструктором, то конструктор
для  базового   класса  вызывается   до  вызова   конструктора  для
производного класса. Конструкторы для объектов членов, если таковые
есть,  выполняются   после  конструктора   базового  класса   и  до
конструктора объекта,  содержащего их.  Объяснение того,  как могут
быть специфицированы параметры для базового класса, см. в <a
href="#ref8.6.2">#8.6.2</a>, а того,  как   конструкторы  могут   использоваться  для   управления свободной памятью, см. в <a
href="ref9_18.htm#ref9_18.17">#17.</a>
<a name="ref8.5.6">
</a></pre>

<h4 align="center"><a name="ref8.5.6">8.5.6
Преобразования</a></h4>

<p><a name="ref8.5.6">Конструктор,
получающий один параметр,
определяет преобразование из типа
своего параметра в тип своего
класса. Такие преобразования
неявно применяются дополнительно к
обычным арифметическим
преобразованиям. Поэтому
присваивание объекту из класса X
допустимо, если или присваиваемое
значение является X, или если X имеет
конструктор, который получает
присваиваемое значение как свой
единственный параметр. Аналогично
конструкторы используются для
преобразования параметров функции
(</a><a href="ref1_7.htm#ref1_7.7.1">#7.1</a>) и
инициализаторов (<a href="#ref8.6">#8.6</a>).
Например: </p>

<pre>
  class X { ... X (int); };
  f (X arg)
    {
      X a = 1;          /* a = X (1) */
      a = 2;            /* a = X (2) */
      f (3);            /* f (X (3)) */
    }
</pre>

<pre>
  Если для  класса X  не  найден  ни один  конструктор,  принимающий
присваиваемый  тип,   то  не   делается  никаких  попыток  отыскать
конструктор для  преобразования присваиваемого  типа в тип, который
мог бы быть приемлем для конструкторов класса  X. Например:
</pre>

<pre>
  class X { ... X (int); };
  class X { ... Y (X); };

  Y a = 1;              /* недопустимо: Y (X (1)) не пробуется */
</pre>

<h4 align="center"><a name="ref8.5.7">8.5.7
Деструкторы</a></h4>

<p><a name="ref8.5.7">Функция член класса cl с
именем ~cl называется деструктором.
Деструктор не возвращает никакого
значения и не получает никаких
параметров; он используется для
уничтожения значений типа cl
непосредственно перед
уничтожением содержащего их
объекта. Деструктор не может быть
overload, virtual или friend. </a></p>

<p><a name="ref8.5.7">Деструктор для
базового класса выполняется после
деструктора производного от него
класса. Как деструкторы
используются для управления
свободной памятью, см. объяснение в </a><a
href="ref9_18.htm#ref9_18.17">#17.</a> </p>

<h4 align="center"><a name="ref8.5.8">8.5.8 Видимость
имен членов</a></h4>

<p><a name="ref8.5.8">Члены класса, описанные
с ключевым словом class, являются
закрытыми, это значит, что их имена
могут использоваться только
функциями членами (</a><a href="#ref8.5.2">#8.5.2</a>)
и друзьями (см. <a href="#ref8.5.10">#8.5.10</a>),
пока они не появятся после метки
public: . В этом случае они являются
общими. Общий член может
использоваться любой функцией.
Структура является классом, все
члены которого общие; см. <a
href="#ref8.5.11">#8.5.11.</a> <br>
Если перед именем базового класса в
описании производного класса стоит
ключевое слово public, то общие члены
базового класса являются общими
для производного класса; если нет,
то они являются закрытыми. Общий
член mem закрытого базового класса
base может быть описан как общий для
производного класса с помощью
описания вида </p>

<pre>
     typedef-имя . идентификатор;
</pre>

<pre>
  в котором  typedef-имя означает базовый класс, а идентификатор есть
имя члена  базового класса. Такое описание может появляться в общей
части производного класса.

  Рассмотрим
</pre>

<pre>
  class base
    {
      int a;
  public:
      int b,c;
      int bf ();
    };

  class derived : base
    {
      int d;
  public:
      base.c;
      int e;
      int df ();
    };

  int ef (derived&amp;);
</pre>

<pre>
  Внешняя функция  ef может  использовать только  имена c,  e и df.
Являясь членом  derived, функция df может использовать имена b,  c,
bf, d,  e    и   df, но не a. Являясь членом base, функция bf может
использовать члены a, b, c  и  bf.
<a name="ref8.5.9">
</a></pre>

<h4 align="center"><a name="ref8.5.9">8.5.9 Друзья
(friends)</a></h4>

<p><a name="ref8.5.9">Другом класса является
функция не-член, которая может
использовать имена закрытых
членов. Следующий пример
иллюстрирует различия между
членами и друзьями: </a></p>

<pre><a name="ref8.5.9">
  class private
    {
      int a;
      friend void friend_set (private*,int);
  public:
      void member_set (int);
    };

  void friend_set (private* p,int i) { p-&gt;a=i; }

  void private.member_set (int i) { a = i; }

  private obj;

  friend_set (&amp;obj,10);

  obj.member_set (10);
</a></pre>

<pre><a name="ref8.5.9">
  Если  описание   friend  относится  к  перегруженному  имени  или
операции, то  другом становится  только функция с описанными типами
параметров. Все  функции класса  cl1 могут  быть  сделаны  друзьями
класса cl2 с помощью одного описания
</a></pre>

<pre><a name="ref8.5.9">
  class cl2
    {
      friend cl1;
      . . .
    };
</a></pre>

<h4 align="center"><a name="ref8.5.10">8.5.10 Функция
операция</a></h4>

<p><a name="ref8.5.10">Большинство операций
могут быть перегружены с тем, чтобы
они могли получать в качестве
операндов объекты класса. </a></p>

<pre><a name="ref8.5.10">
      имя_функции_операции:   operator  op
    op:            +   -   *   /   %   ^   &amp;   |   ~
                   !   =   <>   +=  -=  *=  /=  %=
                   ^=  &amp;=  |=  <<>&gt;  <<=>&gt;= ==  !=
                   <=>=  &amp;&amp;  ||  ++  --  ()  []
</a></pre>

<pre><a name="ref8.5.10">
  Последние две  операции  -  это  вызов  функции  и  индексирование.
Функция операция  может или  быть функцией  членом, или получать по
меньшей мере один параметр класса. См. также </a><a
href="ref1_7.htm#ref1_7.7.16">#7.16.</a>
<a name="ref8.5.11">
</a></pre>

<h4 align="center"><a name="ref8.5.11">8.5.11 Структуры</a></h4>

<p><a name="ref8.5.11">Структура есть класс,
все члены которого общие. Это
значит, что </a></p>

<pre><a name="ref8.5.11">
  struct s { ... };
</a></pre>

<pre><a name="ref8.5.11">
эквивалентно
</a></pre>

<pre><a name="ref8.5.11">
  class s { public: ... };
</a></pre>

<pre><a name="ref8.5.11">
  Структура может  иметь  функции  члены  (включая  конструкторы  и
деструкторы).
</a><a name="ref8.5.12">
</a></pre>

<h4 align="center"><a name="ref8.5.12">8.5.12
Объединения</a></h4>

<p><a name="ref8.5.12">Объединение можно
считать структурой, все объекты
члены которой начинаются со
смещения 0, и размер которой
достаточен для содержания любого
из ее объектов членов. В каждый
момент времени в объединении может
храниться не больше одного из
объектов членов. Объединение может
иметь функции члены (включая
конструкторы и деструкторы). </a></p>

<h4 align="center"><a name="ref8.5.13">8.5.13 Поля бит</a></h4>

<p><a name="ref8.5.13">Описатель члена вида </a></p>

<pre><a name="ref8.5.13">
     идентификатор opt:  константное_выражение
</a></pre>

<pre><a name="ref8.5.13">
  определяет поле;  его длина  отделяется от  имени поля  двоеточием.
Поля упаковываются  в машинные целые; они не являются альтернативой
слов. Поле  , не влезающее в оставшееся в целом место, помещается в
следующее слово.  Поле не  может  быть  шире  слова.  На  некоторых
машинах  они  размещаются  справа  налево,  а  на  некоторых  слева
направо; см. </a><a href="ref1_7.htm#ref1_7.2.6">#2.6.</a>

Неименованные поля полезны при заполнении для согласования внешне
предписанных размещений  (форматов). В особых случаях неименованные
поля длины  0 задают выравнивание следующего поля по границе слова.
Не требуется  аппаратной поддержки  любых полей, кроме целых. Более
того, даже  целые поля  могут рассматриваться как unsigned. По этим
причинам рекомендуется  описывать поля  как unsigned.  К  полям  не
может  применяться   операция  получения   адреса  &amp;,  поэтому  нет
указателей на поля.

  Поля не могут быть членами объединения.
<a name="ref8.5.14">
</a></pre>

<h4 align="center"><a name="ref8.5.14">8.5.14 Вложенные
классы </a></h4>

<p><a name="ref8.5.14">Класс может быть
описан внутри другого класса. В
этом случае область видимости имен
внутреннего класса его и общих имен
ограничивается охватывающим
классом. За исключением этого
ограничения допустимо, чтобы
внутренний класс уже был описан вне
охватывающего класса. Описание
одного класса внутри другого не
влияет на правила доступа к
закрытым членам и не помещает
функции члены внутреннего класса в
область видимости охватывающего
класса. Например: </a></p>

<pre><a name="ref8.5.14">
  int x;

  class enclose   /* охватывающий */
    {
      int x;
      class inner
        {
          int y;
          f () { x=1 }
          ...
        };
      g (inner*);
      ...
    };

  int inner;  /* вложенный */

  enclose.g (inner* p) { ... }
</a></pre>

<pre><a name="ref8.5.14">
  В этом  примере x  в f  ссылается на  x, описанный  перед классом
enclose. Поскольку  y является  закрытым членом  inner,  g не может
его использовать.  Поскольку g   является  членом  enclose,  имена,
использованные в  g, считаются  находящимися  в  области  видимости
класса enclose.   Поэтому inner в описании параметров g относится к
охваченному типу inner, а не к int.
</a><a name="ref8.6">
</a></pre>

<h3 align="center"><a name="ref8.6">8.6
Инициализация</a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref8.6"></a>&nbsp;</td>
        <td><a href="#ref8.6.1">8.6.1 Список
        инициализаторов </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.6.2">8.6.2 Классовые
        объекты </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.6.3">8.6.3 Ссылки </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref8.6.4">8.6.4 Массивы
        символов </a></td>
    </tr>
</table>

<p>Описание может задавать
начальное значение описываемого
идентификатора. Инициализатору
предшествует =, и он состоит из
выражения или списка значений,
заключенного в фигурные скобки. </p>

<pre>
     инициализатор:
          =                                              expression
          =          {           список_инициализаторов           }
          =       {        список_инициализаторов        ,        }
          (                   список_выражений                    )

     список_инициализаторов                                       :
          выражение
          список_инициализаторов      ,      список_инициализаторов
          { список_инициализаторов }
</pre>

<pre>
    Все выражения в инициализаторе статической или внешней переменной
должны быть  константными выражениями,  которые описаны в <a
href="ref9_18.htm#ref9_18.15">#15</a>  или
выражениями, которые сводятся к адресам ранее описанных переменных,
возможно со  смещением на  константное выражение.  Автоматические и
регистровые переменные могут инициализироваться любыми выражениями,
включающими константы, ранее описанные переменные и функции.

  Гарантируется, что  неинициализированные  статические  и  внешние
переменные  получают   в  качестве   начального  значения   &quot;пустое
значение&quot;<a href="#*r.1">*<sup>1</sup></a>. Когда  инициализатор применяется  к скаляру  (указатель или объект  арифметического типа),  он состоит из одного выражения,
возможно, заключенного  в  фигурные  скобки.  Начальное    значение
объекта находится  из выражения;  выполняются те же преобразования,
что и при присваивании.

  Заметьте, что  поскольку ()  не является  инициализатором, то  &quot;X
a();&quot; является  не описанием объекта класса X, а описанием функции,
не получающей значений и возвращающей X.
<a name="ref8.6.1">
</a></pre>

<h4 align="center"><a name="ref8.6.1">8.6.1 Список
инициализаторов</a></h4>

<p><a name="ref8.6.1">Когда описанная
переменная является составной
(класс или массив), то инициализатор
может состоять из заключенного в
фигурные скобки, разделенного
запятыми списка инициализаторов
для членов составного объекта, в
порядке возрастания индекса или по
порядку членов. Если массив
содержит составные подобъекты, то
это правило рекурсивно применяется
к членам составного подобъекта.
Если инициализаторов в списке
меньше, чем членов в составном
подобъекте, то составной подобъект
дополняется нулями. <br>
Фигурные скобки могут опускаться
следующим образом. Если
инициализатор начинается с левой
фигурной скобки, то следующий за
ней список инициализаторов
инициализирует члены составного
объекта; наличие числа
инициализаторов, большего, чем
число членов, считается ошибочным.
Если, однако, инициализатор не
начинается с левой фигурной скобки,
то из списка берутся только
элементы, достаточные для
сопоставления членам составного
объекта, частью которого является
текущий составной объект. <br>
Например, </a></p>

<pre><a name="ref8.6.1">
  int x[] = { 1, 3, 5 };
</a></pre>

<pre><a name="ref8.6.1">
описывает и  инициализирует x  как одномерный  массив, имеющий  три
члена, поскольку размер не был указан и дано три инициализатора.
</a></pre>

<pre><a name="ref8.6.1">
  float y[4][3] =
      {
        { 1, 3, 5 },
        { 2, 4, 6 },
        { 3, 5, 7 }
      };
</a></pre>

<pre><a name="ref8.6.1">
является полностью  снабженной квадратными скобками инициализацией:
1,3 и 5 инициализируют  первый ряд массива y[0], а именно, y[0][2].
Аналогично, следующие  две строки  инициализируют    y[1]  и  y[2].
Инициализатор заканчивается  раньше, поэтому  y[3] инициализируется
значением    0.  В точности  тот же  эффект может  быть достигнут с
помощью
</a></pre>

<pre><a name="ref8.6.1">
  float y[4][3] =
    {
      1, 3, 5, 2, 4, 6, 3, 5, 7
    };
</a></pre>

<pre><a name="ref8.6.1">
  Инициализатор для  y начинается  с левой  фигурной скобки,  но не
начинается с  нее инициализатор  для y[0], поэтому используется три
значения из  списка. Аналогично, следующие три успешно используются
для y[1] и следующие три для y[2].
</a></pre>

<pre><a name="ref8.6.1">
  float y[4][3] = { { 1 }, { 2 }, { 3 }, { 4 } };
</a></pre>

<pre><a name="ref8.6.1">
инициализирует   первый столбец  y (рассматриваемого  как двумерный
массив) и оставляет остальные элементы нулями.
</a><a name="ref8.6.2">
</a></pre>

<h4 align="center"><a name="ref8.6.2">8.6.2 Классовые
объекты</a></h4>

<p><a name="ref8.6.2">Объект с закрытыми
членами не может быть
инициализован с помощью простого
присваивания, как это описывалось
выше; это же относится к объекту
объединение. Если класс имеет
конструктор, не получающий
значений, то этот конструктор
используется для объектов, которые
явно не инициализированы. <br>
Параметры для конструктора могут
также быть представлены в виде
заключенного в круглые скобки
списка. Например: </a></p>

<pre><a name="ref8.6.2">
  struct complex
    {
      float re;
      float im;
      complex (float r,float i) { re=r; im=i; }
      complex (float r) { re=r; im=0; }
    };

  complex zz (1,2.3);
  complex* zp = new complex (1,2.3);
</a></pre>

<pre><a name="ref8.6.2">
  Инициализация  может   быть  также  выполнена  с  помощью  явного
присваивания; преобразования производятся. Например,
</a></pre>

<pre><a name="ref8.6.2">
  complex zz1 = complex (1,2.3);
  complex zz2 = complex (123);
  complex zz3 = 123;
  complex zz4 = zz3;
</a></pre>

<pre><a name="ref8.6.2">
  Если конструктор  ссылается на объект своего собственного класса,
то он  будет вызываться  при инициализации  объекта другим объектом
этого класса, но не при инициализации объекта конструктором.

  Объект  класса,   имеющего  конструкторы,   может   быть   членом
составного объекта  только если  он сам  не имеет  конструктора или
если его  конструкторы не  имеют  параметров.  В  последнем  случае
конструктор вызывается  при создании  составного объекта. Если член
составного объекта  является членом класса с деструкторами, то этот
деструктор вызывается при уничтожении составного объекта.
</a><a name="ref8.6.3">
</a></pre>

<h4 align="center"><a name="ref8.6.3">8.6.3 Ссылки</a></h4>

<p><a name="ref8.6.3">Когда переменная
описана как T&amp;, что есть &quot;ссылка
на тип T&quot;, она может быть
инициализирована или указателем на
тип T, или объектом типа T. В
последнем случае будет неявно
применена операция взятия адреса
&amp;. Например: </a></p>

<pre><a name="ref8.6.3">
  int i;
  int&amp; r1 = i;
  int&amp; r2 = &amp;i
</a></pre>

<pre><a name="ref8.6.3">
И r1 и r2 будут указывать на i.

  Обработка инициализации  ссылки очень сильно зависит от того, что
ей  присваивается.   Как  описывалось   в   </a><a
href="ref1_7.htm#ref1_7.7.1">#7.1</a>,   ссылка   неявно
переадресуется при ее использовании. Например
</pre>

<pre>
  r1 = r2;
</pre>

<pre>
означает копирование  целого, на  которое указывает r2, в целое, на
которое указывает r1.

  Ссылка должна  быть инициализована.  Таким образом,  ссылку можно
считать именем объекта.

  Чтобы получить указатель pp, обозначающий тот объект, что и ссылка
rr, можно  написать pp=&amp;rr.    Это  будет  проинтерпретировано  как
pp=&amp;*rr.

  Если инициализатор  для ссылки  на тип  T  не  является  адресным
выражением, то  будет  создан  и  инициализован  с  помощью  правил
инициализации объект  типа T.  Тогда значением  ссылки станет адрес
объекта. Время  жизни объекта,  созданного таким  способом, будет в
той области видимости, в которой он создан. Например:
</pre>

<pre>
  double&amp; rr = 1;
</pre>

<pre>
допустимо, и  rr будет  указывать на  объект типа double, в котором
хранится значение 1.0.

  Ссылки особенно полезны в качестве типов параметров.
<a name="ref8.6.4">
</a></pre>

<h4 align="center"><a name="ref8.6.4">8.6.4 Массивы
символов</a></h4>

<p><a name="ref8.6.4">Последняя сокращенная
запись позволяет инициализировать
строкой массив данных типа char. В
этом случае последовательные
символы строки инициализируют
члены массива. Например: </a></p>

<pre><a name="ref8.6.4">
  char msg[] = &quot;Syntax error on line %d\n&quot;;
</a></pre>

<pre><a name="ref8.6.4">
демонстрирует  массив  символов,  члены  которого  инициализированы
строкой.
</a><a name="ref8.7">
</a></pre>

<h3 align="center"><a name="ref8.7">8.7 Имена типов</a></h3>

<p><a name="ref8.7">Иногда (для неявного
задания преобразования типов и в
качестве параметра sizeof или new) нужно
использовать имя типа данных. Это
выполняется при помощи &quot;имени
типа&quot; которое по сути является
описанием для объекта этого типа, в
котором опущено имя объекта. </a></p>

<pre><a name="ref8.7">
     имя_типа:
          спецификатор_типа абстрактный_описатель
     абстрактный_описатель                                        :
          пустой
          *                                   абстрактный_описатель
          абстрактный_описатель    (  списоко_писателей_параметров)
          абстрактный_описатель    [  константное_выражение  opt  ]
          ( абстрактный_описатель )
</a></pre>

<pre><a name="ref8.7">
    Является     возможным      идентифицировать     положение      в
абстрактном_описателе, где должен был бы появляться идентификатор в
случае, если  бы конструкция  была  описателем  в  описании.  Тогда
именованный  тип   является  тем  же,  что  и  тип  предполагаемого
идентификатора. Например:
</a></pre>

<pre><a name="ref8.7">
  int
  int *
  int *[3]
  int *()
  int (*)()
</a></pre>

<pre><a name="ref8.7">
именует,  соответственно,   типы  &quot;целое&quot;,   &quot;указатель  на  целое&quot;,
&quot;указатель  на   массив  из  трех  целых&quot;,  &quot;функция,  возвращающая
указатель на функцию, возвращающую целое&quot; и &quot;указатель на целое&quot;.

  Простое  имя   типа  есть   имя   типа,   состоящее   из   одного
идентификатора или ключевого слова.
</a></pre>

<pre><a name="ref8.7">
     простое_имя_типа:
          typedef-имя
          char
          short
          int
          long
          unsigned
          float
          double
</a></pre>

<pre><a name="ref8.7">
    Они используются  в альтернативном  синтаксисе для преобразования
типов. Например:
</a></pre>

<pre><a name="ref8.7">
  (double) a
</a></pre>

<pre><a name="ref8.7">
может быть также записано как
</a></pre>

<pre><a name="ref8.7">
  double (a)
</a></pre>

<h3 align="center"><a name="ref8.8">8.8 Определение
типа typedef</a></h3>

<p><a name="ref8.8">Описания, содержащие
спецификатор_описания typedef,
определяют идентификаторы, которые
позднее могут использоваться так,
как если бы они были ключевыми
словами типа, именующее основные
или производные типы. </a></p>

<pre><a name="ref8.8">
     typedef-имя:
          идентификатор
</a></pre>

<pre><a name="ref8.8">
    Внутри области  видимости описания,  содержащего typedef,  каждый
идентификатор,  возникающий   как  часть   какого-либо   описателя,
становится в этом месте синтаксически эквивалентным ключевому слову
типа, которое  именует тип, ассоциированный с идентификатором таким
образом, как  описывается в </a><a
href="#ref8.4">#8.4.</a> Имя класса или перечисления также
является typedef-именем. Например, после
</pre>

<pre>
  typedef int MILES, *KLICKSP;
  struct complex { double re, im; };
</pre>

<pre>
каждая из конструкций
</pre>

<pre>
  MILES distance;
  extern KLICKSP metricp;
  complex z, *zp;
</pre>

<pre>
является допустимым  описанием; distance  имеет  тип  int,  metricp
имеет тип &quot;указатель на int&quot;.

  typedef   не вводит  новых типов,  но только  синонимы для типов,
которые могли  бы быть  определены другим  путем. Так в приведенном
выше примере  distance рассматривается  как имеющая в точности тот
же тип, что и любой другой int объект.

  Но описание класса вводит новый тип. Например:
</pre>

<pre>
  struct X { int a; };
  struct Y { int a; };
  X a1;
  Y a2;
  int a3;
</pre>

<pre>
описывает три переменных трех различных типов.

  Описание вида
</pre>

<pre>
     описание_имени:
          агрег                   идентификатор                   ;
          enum  идентификатор ;
</pre>

<pre>
  определяет  то,   что  идентификатор   является  именем  некоторого
(возможно, еще  не определенного)  класса или  перечисления.  Такие
описания позволяют  описывать классы,  ссылающихся друг  на  друга.
Например:
</pre>

<pre>
  class vector;
  class matrix
    {
      ...
      friend matrix operator* (matrix&amp;,vector&amp;);
    };

  class vector
    {
      ...
      friend matrix operator* (matrix&amp;,vector&amp;);
    };
</pre>

<h3 align="center"><a name="ref8.9">8.9
Перегруженные имена функций</a></h3>

<p><a name="ref8.9">В тех случаях, когда для
одного имени определено несколько
(различных) описаний функций, это
имя называется перегруженным. При
использовании этого имени
правильная функция выбирается с
помощью сравнения типов
фактических параметров с типами
параметров в описаниях функций. К
перегруженным именам неприменима
операция получения адреса &amp;. <br>
Из обычных арифметических
преобразований, определенных в </a><a
href="ref1_7.htm#ref1_7.6.6">#6.6</a>, для вызова
перегруженной функции выполняются
только char-&gt;short-&gt;int, int-&gt;double, int-&gt;long
и float-&gt;double. Для того, чтобы
перегрузить имя функции не-члена
описание overload должно
предшествовать любому описанию
функции; см. <a href="#ref8.2">#8.2.</a> <br>
Например: </p>

<pre>
  overload abs;
  int abs (int);
  double abs (double);
</pre>

<pre>
  Когда  вызывается  перегруженное  имя,  по  порядку  производится
сканирование списка  функций для нахождения той, которая может быть
вызвана. Например,  abs(12) вызывает  abs(int), а  abs(12.0)  будет
вызывать abs(double). Если бы был зарезервирован порядок вызова, то
оба обращения вызвали бы abs(double).

  Если   в   случае   вызова   перегруженного   имени   с   помощью
вышеуказанного метода  не найдено  ни одной функции,  и если функция
получает параметр типа класса, то конструкторы классов параметров (в
этом случае существует единственный  набор преобразований, делающий
вызов допустимым) применяются неявным образом. Например:
</pre>

<pre>
  class X { ... X (int); };
  class Y { ... Y (int); };
  class Z { ... Z (char*); };

  overload int f (X), f (Y);
  overload int g (X), g (Y);

  f (1);        /* неверно: неоднозначность f(X(1)) или f(Y(1)) */
  g (1);        /* g(X(1))                              */
  g (&quot;asdf&quot;);   /* g(Z(&quot;asdf&quot;))                         */
</pre>

<pre>
Все    имена    функций    операций    являются    автоматически
перегруженными.
<a name="ref8.10">
</a></pre>

<h3 align="center"><a name="ref8.10">8.10 Описание
перечисления</a></h3>

<p><a name="ref8.10">Перечисления являются
int с именованными константами. </a></p>

<pre><a name="ref8.10">
     enum_спецификатор:
          enum    идентификатор     opt     {     enum_список     }

     enum_список:
          перечислитель
          enum_список,                                перечислитель

     перечислитель:
          идентификатор
          идентификатор = константное_выражение
</a></pre>

<pre><a name="ref8.10">
    Идентификаторы  в  enum-списке  описаны  как  константы  и  могут
появляться  во  всех  местах,  где  требуются  константы.  Если  не
появляется  ни   одного  перечислителя   с  =,   то  значения  всех
соответствующих констант  начинаются с  0 и возрастают на 1 по мере
чтения   описания   слева   направо.   Перечислитель   с   =   дает
ассоциированному   с   ним   идентификатору   указанное   значение;
последующие идентификаторы  продолжают прогрессию  от присвоенного
значения.

  Имена  перечислителей  должны  быть  отличными  от  имен  обычных
переменных. Значения  перечислителей  не  обязательно  должны  быть
различными.

  Роль     идентификатора      в     спецификаторе     перечисления
enum_спецификатор  полностью   аналогична  роли  имени  класса;  он
именует определенный нумератор. Например:
</a></pre>

<pre><a name="ref8.10">
  enum color { chartreuse, burgundy, claret=20, winedark };
    ...
    color *cp, col;
    ...
    col = claret;
    cp = &amp;col
    ...
    if (*cp == burgundy) ...
</a></pre>

<pre><a name="ref8.10">
делает color  именем типа, описывающего  различные  цвета,  и  затем
описывает cp как указатель на объект этого типа. Возможные значения
извлекаются из множества { 0, 1, 20, 21 }.
</a><a name="ref8.11">
</a></pre>

<h3 align="center"><a name="ref8.11">8.11 Описание Asm </a></h3>

<p><a name="ref8.11">Описание Asm имеет вид </a></p>

<pre><a name="ref8.11">
    asm (строка);
</a></pre>

<pre><a name="ref8.11">
    Смысл описания  asm  не определен.  Обычно  оно  используется  для
передачи информации ассемблеру через компилятор.
</a></pre>

<p><a name="*r.1"><font size="2">*<sup>1</sup> В
английском &quot;garbage&quot;, означающее
затертое место [памяти], т.е. если
переменная целая, то 0, если char, то
'\0', если указатель на Т, то (Т*) NULL. </font></a></p>

<p align="center"><a name="*r.1"><font size="2">[</font></a><a
href="ref1_7.htm"><font size="2">Назад</font></a><font
size="2">] [</font><a href="ref.htm"><font size="2">Содержание</font></a><font
size="2">] [</font><a href="ref9_18.htm"><font size="2">Вперед</font></a><font
size="2">] </font></p>

<p align="center">&nbsp;</p>
</body>
</html>
