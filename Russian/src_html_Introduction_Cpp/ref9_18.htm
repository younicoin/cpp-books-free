<htm>
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Бьярн Страустрап. Введение в язык Си++, Операторы</title>
</head>

<body bgcolor="#FFF5EE" link="#FF0000" vlink="#A52A2A"
alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h2 align="center"><a name="ref9_18">9. Операторы </a></h2>

<p><a name="ref9_18">Операторы выполняются
последовательно во всех случаях
кроме особо оговоренных. </a></p>

<h3 align="center"><a name="ref9_18.9.1">9.1 Оператор
выражение </a></h3>

<p><a name="ref9_18.9.1">Большинство
операторов является операторами
выражение, которые имеют вид
выражение ; <br>
Обычно операторы выражение
являются присваиваниями и вызовами
функций. </a></p>

<h3 align="center"><a name="ref9_18.9.2">9.2 Составной
оператор, или блок </a></h3>

<p><a name="ref9_18.9.2">Составной оператор
(называемый также &quot;блок&quot;, что
эквивалентно) дает возможность
использовать несколько операторов
в том месте, где предполагается
использование одного: </a></p>

<pre><a name="ref9_18.9.2">
     составной_оператор:
          { список_описаний opt список_операторов opt }
     список_описаний:
          описание
          описание список_описаний
     список_операторов:
          оператор
          оператор список_операторов
</a></pre>

<p><a name="ref9_18.9.2"><br>
Если какой-либо из идентификаторов
в списке_описаний был ранее описан,
то внешнее описание выталкивается
на время выполнения блока, и снова
входит в силу по его окончании.
Каждая инициализация auto или register
переменных производится всякий раз
при входе в голову блока. В блок
делать передачу; в этом случае
инициализации не выполняются.
Инициализации переменных, имеющих
класс памяти static (</a><a
href="ref1_7.htm#ref1_7.4.2">#4.2</a>)
осуществляются только один раз в
начале выполнения программы. </p>

<h3 align="center"><a name="ref9_18.9.3">9.3 Условный
оператор </a></h3>

<p><a name="ref9_18.9.3">Есть два вида
условных операторов </a></p>

<pre><a name="ref9_18.9.3">
     if ( выражение ) оператор 
     if ( выражение ) оператор else оператор
</a></pre>

<p><a name="ref9_18.9.3"><br>
В обоих случаях вычисляется
выражение, и если оно не ноль, то
выполняется первый подоператор. Во
втором случае второй подоператор
выполняется, если выражение есть 0.
Как обычно, неоднозначность
&quot;else&quot; разрешается посредством
того, что else связывается с
последним встречным if, не имеющим
else. </a></p>

<h3 align="center"><a name="ref9_18.9.4">9.4 Оператор
while </a></h3>

<p><a name="ref9_18.9.4">Оператор while имеет вид
</a></p>

<pre><a name="ref9_18.9.4">
     while ( выражение ) оператор
</a></pre>

<p><a name="ref9_18.9.4"><br>
Выполнение подоператора
повторяется, пока значение
выражения остается ненулевым.
Проверка выполняется перед каждым
выполнением оператора. </a></p>

<h3 align="center"><a name="ref9_18.9.5">9.5 Оператор do </a></h3>

<p><a name="ref9_18.9.5">Оператор do имеет вид </a></p>

<pre><a name="ref9_18.9.5">
    do оператор while (выражение);
</a></pre>

<p><a name="ref9_18.9.5"><br>
Выполнение подоператора
повторяется до тех пор, пока
значение выражения не станет нулем.
Проверка выполняется после каждого
выполнения оператора. </a></p>

<h3 align="center"><a name="ref9_18.9.6">9.6 Оператор for
</a></h3>

<p><a name="ref9_18.9.6">Оператор for имеет вид </a></p>

<pre><a name="ref9_18.9.6">
     for (  выражение_1 opt  ; выражение_2  opt ; выражение_3 opt )
          оператор
</a></pre>

<p><a name="ref9_18.9.6"><br>
Этот оператор эквивалентен
следующему: </a></p>

<pre><a name="ref9_18.9.6">
     выражение_1;
     while    (выражение_2)
                  {
                   оператор
                                выражение_3;
                   }
</a></pre>

<p><a name="ref9_18.9.6"><br>
Первое выражение задает
инициализацию цикла; второе
выражение задает осуществляемую
перед каждой итерацией проверку, по
которой производится выход из
цикла, если выражение становится
нулем; третье выражение часто
задает приращение, выполняемое
после каждой итерации. <br>
Каждое или все выражения могут быть
опущены. Отсутствие выражения_2
делает подразумеваемое
while-предложение эквивалентным while(1);
остальные опущенные выражения
просто пропускаются в описанном
выше расширении. </a></p>

<h3 align="center"><a name="ref9_18.9.7">9.7 Оператор
switch </a></h3>

<p><a name="ref9_18.9.7">Оператор switch вызывает
передачу управления на один из
нескольких операторов в
зависимости от значения выражения.
Он имеет вид </a></p>

<pre><a name="ref9_18.9.7">
     switch ( выражение ) оператор
</a></pre>

<p><a name="ref9_18.9.7"><br>
Выражение должно быть целого типа
или типа указателя. Любой оператор
внутри оператора может быть
помечен одним или более префиксом
case следующим образом: </a></p>

<pre><a name="ref9_18.9.7">
     case      константное_выражение :
</a></pre>

<p><a name="ref9_18.9.7"><br>
где константное выражение должно
иметь тот же тип что и выражение-
переключатель; производятся
обычные арифметические
преобразования. В одном операторе
switch никакие две константы,
помеченные case, не могут иметь
одинаковое значение. Константные
выражения точно определяются в </a><a
href="#ref9_18.15">#15.</a> <br>
Может также быть не более чем один
префикс оператора вида </p>

<pre>
     default :
</pre>

<p><br>
Когда выполнен оператор switch,
проведено вычисление его выражения
и сравнение его с каждой case
константой. Если одна из констант
равна значению выражения, то
управление передается на
выражение, следующее за подошедшим
префиксом case. Если никакая case
константа не соответствует
выражению, и есть префикс default, то
управление передается на
выражение, которому он
предшествует. Если нет
соответствующих вариантов case и default
отсутствует, то никакой из
операторов в операторе switch не
выполняется. <br>
Префиксы case и default сами по себе не
изменяют поток управления, который
после задержки идет дальше,
перескакивая через эти префиксы.
Для выхода из switch см. break, <a
href="#ref9_18.9.8">#9.8.</a> <br>
Обычно зависящий от switch оператор
является составным. В голове этого
оператора могут стоять описания, но
инициализации автоматических и
регистровых переменных являются
безрезультатными. </p>

<h3 align="center"><a name="ref9_18.9.8">9.8 Оператор
break </a></h3>

<p><a name="ref9_18.9.8">Оператор </a></p>

<pre><a name="ref9_18.9.8">
     break ;
</a></pre>

<p><a name="ref9_18.9.8"><br>
прекращает выполнение ближайшего
охватывающего while, do, for или switch
оператора; управление передается
на оператор, следующий за
законченным. </a></p>

<h3 align="center"><a name="ref9_18.9.9">9.9 Оператор
continue </a></h3>

<p><a name="ref9_18.9.9">Оператор </a></p>

<pre><a name="ref9_18.9.9">
  continue ;
</a></pre>

<p><a name="ref9_18.9.9"><br>
вызывает передачу управления на
управляющую продолжением цикла
часть наименьшего охватывающего
оператора while, do или for; то есть на
конец петли цикла. Точнее, в каждом
из операторов </a></p>

<table border="0" width="100%">
    <tr>
        <td><pre><a name="ref9_18.9.9">while (...)</a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">do</a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9"> for (...)</a></pre>
        </td>
    </tr>
    <tr>
        <td><pre><a name="ref9_18.9.9">{    </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">{ </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">{  </a></pre>
        </td>
    </tr>
    <tr>
        <td><pre><a name="ref9_18.9.9">  ... </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">   ... </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">   ... </a></pre>
        </td>
    </tr>
    <tr>
        <td><pre><a name="ref9_18.9.9">contin:;</a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">contin:;</a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">contin:; </a></pre>
        </td>
    </tr>
    <tr>
        <td><pre><a name="ref9_18.9.9">}    </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">}    </a></pre>
        </td>
        <td><pre><a name="ref9_18.9.9">} </a></pre>
        </td>
    </tr>
    <tr>
        <td><a name="ref9_18.9.9"></a>&nbsp;</td>
        <td><pre><a name="ref9_18.9.9">while (...);</a></pre>
        </td>
        <td><a name="ref9_18.9.9"></a>&nbsp;</td>
    </tr>
</table>

<p><a name="ref9_18.9.9"><br>
continue эквивалентно goto contin. (За contin:
следует пустой оператор, </a><a
href="#ref9_18.9.13">#9.13.</a>) </p>

<h3 align="center"><a name="ref9_18.9.10">9.10 Оператор
return </a></h3>

<p><a name="ref9_18.9.10">Возврат из функции в
вызывающую программу
осуществляется с помощью оператора
return, имеющего один из двух видов: </a></p>

<pre><a name="ref9_18.9.10">
      return ;
      return выражение ;
</a></pre>

<p><a name="ref9_18.9.10"><br>
Первый может использоваться только
в функциях, не возвращающих
значения, т.е. в функциях с типом
возвращаемого значения void. Вторая
форма может использоваться только
в функциях, не возвращающих
значение; вызывающей функцию
программе возвращается значение
выражения. Если необходимо, то
выражение преобразуется, как это
делается при присваивании, к типу
функции, в которой оно возникло.
Обход конца функции эквивалентен
возврату return без возвращаемого
значения. </a></p>

<h3 align="center"><a name="ref9_18.9.11">9.11 Оператор
goto </a></h3>

<p><a name="ref9_18.9.11">Можно осуществлять
безусловную передачу управления с
помощью оператора </a></p>

<pre><a name="ref9_18.9.11">
      goto идентификатор ;
</a></pre>

<p><a name="ref9_18.9.11"><br>
Идентификатор должен быть меткой (</a><a
href="#ref9_18.9.12">#9.12</a>), расположенной в
текущей функции. </p>

<h3 align="center"><a name="ref9_18.9.12">9.12
Помеченные операторы </a></h3>

<p><a name="ref9_18.9.12">Перед любым
оператором может стоять префикс
метка, имеющий вид </a></p>

<pre><a name="ref9_18.9.12"> 
    идентификатор :
</a></pre>

<p><a name="ref9_18.9.12"><br>
который служит для описания
идентификатора как метки. Метка
используется только как объект для
goto. Областью видимости метки
является текущая функция, исключая
любой подблок, в котором был
переписан такой же идентификатор.
См. </a><a href="ref1_7.htm#ref1_7.4.1">#4.1.</a> </p>

<h3 align="center"><a name="ref9_18.9.13">9.13 Пустой
оператор </a></h3>

<p><a name="ref9_18.9.13">Пустой оператор
имеет вид </a></p>

<pre><a name="ref9_18.9.13"> 
    ;
</a></pre>

<p><a name="ref9_18.9.13"><br>
Пустой оператор используется для
помещения метки непосредственно
перед } составного оператора или
того, чтобы снабдить такие
операторы, как while, пустым телом. </a></p>

<h3 align="center"><a name="ref9_18.9.14">9.14 Оператор
delete </a></h3>

<p><a name="ref9_18.9.14">Оператор delete имеет
вид </a></p>

<pre><a name="ref9_18.9.14">
     delete выражение ;
</a></pre>

<p><a name="ref9_18.9.14"><br>
Результатом выражения должен быть
указатель. Объект, на который он
указывает, уничтожается. Это
значит, что после оператора
уничтожения delete нельзя
гарантировать, что объект имеет
определенное значение; см. </a><a
href="#ref9_18.17">#17.</a> Эффект от
применения delete к указателю, не
полученному из операции new (<a
href="ref1_7.htm#ref1_7.7.1">#7.1</a>), не определен.
Однако, уничтожение указателя с
нулевым значением безопасно. </p>

<h3 align="center"><a name="ref9_18.9.15">9.15 Оператор
asm </a></h3>

<p><a name="ref9_18.9.15">Оператор asm имеет вид </a></p>

<pre><a name="ref9_18.9.15">
     asm ( строка) ;
</a></pre>

<p><a name="ref9_18.9.15"><br>
Смысл оператора asm не определен.
Обычно он используется для
передачи информации через
компилятор ассемблеру. </a></p>

<h2 align="center"><a name="ref9_18.10">10. Внешние
Определения </a></h2>

<p><a name="ref9_18.10">Программа на C++
состоит из последовательности
внешних определений. Внешнее
определение описывает
идентификатор как имеющий класс
памяти static и определяет его тип.
Спецификатор типа (</a><a href="ref8.htm#ref8.2">#8.2</a>)
может также быть пустым, и в этом
случае принимается тип int. Область
видимости внешних определений
простирается до конца файла, в
котором они описаны, так же, как
действие описаний сохраняется до
конца блока. Синтаксис внешних
определений тот же, что и у
описаний, за исключением того, что
только на этом уровне и внутри
описаний классов может быть задан
код (текст программы) функции. </p>

<h3 align="center"><a name="ref9_18.10.1">10.1
Определения функций </a></h3>

<p><a name="ref9_18.10.1">Определения функций
имеют вид </a></p>

<pre><a name="ref9_18.10.1"> 
    определение_функции:
          спецификаторы_описания описатель_функции  opt инициализатор_базового_класса opt
          тело_функции
</a></pre>

<p><a name="ref9_18.10.1"><br>
Единственными cпецификаторами
класса памяти (sc-cпецификаторами),
допустимыми среди спецификаторов
описания, являются extern, static, overload,
inline и virtual. Описатель функции похож
на описатель &quot;функции,
возвращающей ...&quot;, за исключением
того, что он включает в себя имена
формальных параметров
определяемой функции. <br>
Описатель функции имеет вид </a></p>

<pre><a name="ref9_18.10.1">
     описатель_функции:
          описатель ( список_описаний_параметров )
</a></pre>

<p><a name="ref9_18.10.1"><br>
Форма списка описаний параметров
определена в </a><a href="ref8.htm#ref8.4">#8.4.</a>
Единственный класс памяти, который
может быть задан, это тот, при
котором соответствующий
фактический параметр будет
скопирован, если это возможно, в
регистр при входе в функцию. Если в
качестве инициализатора для
параметра задано константное
выражение, то это значение
используется как значение
параметра по умолчанию. <br>
Тело функции имеет вид </p>

<pre>
     тело_функции:
          составной_оператор
</pre>

<p><br>
Вот простой пример полного
определения функции: </p>

<pre>
  int max (int a,int b,int c)
    {
      int m = (a &gt; b) ? a : b;
      return  (m &gt; c) ? m : c;
    }
</pre>

<p><br>
Здесь int является спецификатором
типа ; max (int a, int b, int c) является
описателем функции ; { ... } - блок,
задающий текст программы (код)
оператора. <br>
Поскольку в контексте выражения
имя (точнее, имя как формальный
параметр) считается означающим
указатель на первый элемент
массива, то описания формальных
параметров, описанных как
&quot;массив из ...&quot;, корректируются
так, чтобы читалось &quot;указатель на
...&quot;. <br>
Инициализатор базового класса
имеет вид </p>

<pre>
     инициализатор_базового_класса:
          : ( список_параметров opt )
</pre>

<p><br>
Он используется для задания
параметров конструктора базового
класса в конструкторе производного
класса. Например: </p>

<pre>
  struct base { base (int); ... };
  struct derived : base { derived (int); ... };

  derived.derived (int a) : (a+1) { ... }

  derived d (10);
</pre>

<p><br>
Конструктор базового класса
вызывается для объекта d с
параметром 11. </p>

<h3 align="center"><a name="ref9_18.10.2">10.2
Определения внешних данных </a></h3>

<p><a name="ref9_18.10.2">Определения внешних
данных имеют вид </a></p>

<pre><a name="ref9_18.10.2">
     определение_данных:
          описание
</a></pre>

<p><a name="ref9_18.10.2"><br>
Класс памяти таких данных
статический. <br>
Если есть более одного определения
внешних данных одного имени, то
определения должны точно
согласовываться по типу и классу
памяти, и инициализаторы (если они
есть), должны иметь одинаковое
значение. </a></p>

<h2 align="center"><a name="ref9_18.11">11. Правила
Области Видимости </a></h2>

<p><a name="ref9_18.11">См. </a><a href="ref1_7.htm#ref1_7.4.1">#4.1.</a>
</p>

<h2 align="center"><a name="ref9_18.12">12. Командные
Строки Компилятора </a></h2>

<p><a name="ref9_18.12">Компилятор языка C++
содержит препроцессор, способный
выполнять макроподстановки,
условную компиляцию и включение
именованных файлов. Строки,
начинающиеся с #, относятся к
препроцессору. Эти строки имеют
независимый от остального языка
синтаксис; они могут появляться в
любом месте оказывать влияние,
которое распространяется
(независимо от области видимости)
до конца исходного файла программы.
<br>
Заметьте, что определения const и inline
дают альтернативы для большинства
использований #define. </a></p>

<h3 align="center"><a name="ref9_18.12.1">12.1 Замена
идентификаторов </a></h3>

<p><a name="ref9_18.12.1">Командная строка
компилятора имеет вид </a></p>

<pre><a name="ref9_18.12.1">
     #define идент строка_символов
</a></pre>

<p><a name="ref9_18.12.1"><br>
вызывает замену препроцессором
последующих вхождений
идентификатора, заданного строкой
символов. Точка с запятой внутри
(или в конце) строки символов
является частью этой строки. <br>
Строка вида </a></p>

<pre><a name="ref9_18.12.1">
     #define идент( идент , ..., идент ) строка_символов
</a></pre>

<p><a name="ref9_18.12.1"><br>
где отсутствует пробел между
первым идентификатором и (,
является макроопределением с
параметрами. Последующие вхождения
первого идентификатора с идущими
за ним (, последовательностью
символов, разграниченной запятыми,
и ), заменяются строкой символов,
заданной в определении. Каждое
местоположение идентификатора,
замеченного в списке параметров
определения, заменяется
соответствующей строкой из вызова.
Фактическими параметрами вызова
являются строки символов,
разделенные запятыми; однако
запятые в строке, заключенной в
кавычки, или в круглых скобках не
являются разделителями параметров.
Число формальных и фактических
параметров должно совпадать.
Строки и символьные константы в
символьной строке сканируются в
поисках формальных параметров, но
строки и символьные константы в
остальной программе не сканируются
в поисках определенных (с помощью
define) идентификаторов. <br>
В обоих случаях строка замещения
еще раз сканируется в поисках
других определенных
идентификаторов. В обоих случаях
длинное определение может быть
продолжено на другой строке с
помощью записи \ в конце
продолжаемой строки. <br>
Командная строка вида </a></p>

<pre><a name="ref9_18.12.1">
     #undef идент
</a></pre>

<p><a name="ref9_18.12.1"><br>
влечет отмену препроцессорного
определения идентификатора. </a></p>

<h3 align="center"><a name="ref9_18.12.2">12.2 Включение
файлов </a></h3>

<p><a name="ref9_18.12.2">Командная строка
компилятора вида </a></p>

<pre><a name="ref9_18.12.2">
     #include &quot;имя_файла&quot;
</a></pre>

<p><a name="ref9_18.12.2"><br>
вызывает замену этой строки полным
содержимым файла имя_файла. Сначала
именованный файл ищется в
директории первоначального
исходного файла, а затем в
стандартных или заданных местах. <br>
Альтернативный вариант, командная
строка вида </a></p>

<pre><a name="ref9_18.12.2">
      #include <имя_файла>
</a></pre>

<p><a name="ref9_18.12.2"><br>
производит поиск только в
стандартном или заданном месте, и
не ищет в директории
первоначального исходного файла.
(То, как эти места задаются, не
является частью языка.) <br>
Включения с помощью #include могут быть
вложенными. </a></p>

<h3 align="center"><a name="ref9_18.12.3">12.3 Условная
компиляция </a></h3>

<p><a name="ref9_18.12.3">Командная строка
компилятора вида </a></p>

<pre><a name="ref9_18.12.3">
     #if выражение
</a></pre>

<p><a name="ref9_18.12.3"><br>
проверяет, является ли результатом
вычисления выражения не-ноль.
Выражение должно быть константным
выражением, которые обсуждаются в </a><a
href="#ref9_18.15">#15</a>; применительно к
использованию данной директивы
есть дополнительные ограничения:
константное выражение не может
содержать sizeof или перечислимые
константы. Кроме обычных операций C
может использоваться унарная
операция defined. В случае применения к
идентификатору она дает значение
не-ноль, если этот идентификатор
был ранее определен с помощью #define и
после этого не было отмены
определения с помощью #undef; иначе ее
значение 0. <br>
Командная строка вида </p>

<pre>
     #ifdef идент
</pre>

<p><br>
проверяет, определен ли
идентификатор в препроцессоре в
данный момент; то есть, был ли он
объектом командной строки #define. <br>
Командная строка вида </p>

<pre>
     #ifndef идент
</pre>

<p><br>
проверяет, является ли
идентификатор неопределенным в
препроцессоре в данный момент. <br>
После строки каждого из трех видов
может стоять произвольное
количество строк, возможно,
содержащих командную строку </p>

<pre>
     #else
</pre>

<p><br>
и далее до командной строки </p>

<pre>
     #endif
</pre>

<p><br>
Если проверенное условие истинно,
то все строки между #else и #endif
игнорируются. Если проверенное
условие ложно, то все строки между
проверкой и #else или, в случае
отсутствия #else, #endif, игнорируются. <br>
Эти конструкции могут быть
вложенными. </p>

<h3 align="center"><a name="ref9_18.12.4">12.4
Управление строкой </a></h3>

<p><a name="ref9_18.12.4">Для помощи другим
препроцессорам, генерирующим
программы на C, строка вида </a></p>

<pre><a name="ref9_18.12.4">
     #line константа &quot;имя_файла&quot;
</a></pre>

<p><a name="ref9_18.12.4"><br>
заставляет компилятор считать,
например, в целях диагностики
ошибок, что константа задает номер
следующей строки исходного файла, и
текущий входной файл именуется
идентификатором. Если
идентификатор отсутствует, то
запомненное имя файла не
изменяется. </a></p>

<h2 align="center"><a name="ref9_18.13">13. Неявные
Описания </a></h2>

<p><a name="ref9_18.13">См. </a><a href="ref8.htm#ref8.1">#8.1.</a>
</p>

<h2 align="center"><a name="ref9_18.14">14. Обзор Типов
</a></h2>

<p><a name="ref9_18.14">В этом разделе кратко
собрано описание действий, которые
могут совершаться над объектами
различных типов. </a></p>

<h3 align="center"><a name="ref9_18.14.1">14.1 Классы </a></h3>

<p><a name="ref9_18.14.1">Классовые объекты
могут присваиваться, передаваться
функциям как параметры и
возвращаться функциями. Другие
возможные операции, как, например,
проверка равенства, могут быть
определены пользователем; см. </a><a
href="ref8.htm#ref8.5.10">#8.5.10.</a> </p>

<h3 align="center"><a name="ref9_18.14.2">14.2 Функции </a></h3>

<p><a name="ref9_18.14.2">Есть только две вещи,
которые можно проделывать с
функцией: вызывать ее и брать ее
адрес. Если в выражении имя функции
возникает не в положении имени
функции в вызове, то генерируется
указатель на функцию. Так, для
передачи одной функции другой
можно написать </a></p>

<pre><a name="ref9_18.14.2">
  typedef int (*PF) ();
  extern g (PF);
  extern f ();
  ...
  g (f);
</a></pre>

<p><a name="ref9_18.14.2"><br>
Тогда определение g может иметь
следующий вид: </a></p>

<pre><a name="ref9_18.14.2">
  g (PF funcp)
    {
      ...
      (*funcp) ();
      ...
    }
</a></pre>

<p><a name="ref9_18.14.2"><br>
Заметьте, что f должна быть описана
явно в вызывающей программе,
поскольку ее появление в g(f) не
сопровождалось (. </a></p>

<h3 align="center"><a name="ref9_18.14.3">14.3 Массивы,
указатели и индексирование </a></h3>

<p><a name="ref9_18.14.3">Всякий раз, когда в
выражении появляется
идентификатор типа массива, он
преобразуется в указатель на
первый член массива. Из-за
преобразований массивы не являются
адресами. По определению операция
индексирования [] интерпретируется
таким образом, что E1[E2] идентично
*((E1)+(E2)). В силу правил
преобразования, применяемых к +,
если E1 массив и E2 целое, то E1[E2]
относится к E2-ому члену E1. Поэтому,
несмотря на такое проявление
асимметрии, индексирование
является коммутативной операцией. <br>
Это правило сообразным образом
применяется в случае многомерного
массива. Если E является n-мерным
массивом ранга i*j*...*k, то
возникающее в выражении E
преобразуется в указатель на
(n-1)-мерный массив ранга j*...*k. Если к
этому указателю, явно или неявно,
как результат индексирования,
применяется операция *, ее
результатом является (n-1)-мерный
массив, на который указывалось,
который сам тут же преобразуется в
указатель. <br>
Рассмотрим, например, </a></p>

<pre><a name="ref9_18.14.3">
  int x[3][5];
</a></pre>

<p><a name="ref9_18.14.3"><br>
Здесь x - массив целых размером 3*5.
Когда x возникает в выражении, он
преобразуется в указатель на
(первый из трех) массив из 5 целых. В
выражении x[i], которое эквивалентно
*(x+1), x сначала преобразуется, как
описано, в указатель, затем 1
преобразуется к типу x, что включает
в себя умножение 1 на длину объекта,
на который указывает указатель, а
именно объект из 5 целых. Результаты
складываются, и используется
косвенная адресация для получения
массива (из 5 целых), который в свою
очередь преобразуется в указатель
на первое из целых. Если есть еще
один индекс, снова используется тот
же параметр; на этот раз результат
является целым. <br>
Именно из всего этого проистекает
то, что массивы в C хранятся по
строкам (быстрее всего изменяется
последний индекс), и что в описании
первый индекс помогает определить
объем памяти, поглощаемый массивом,
но не играет никакой другой роли в
вычислениях индекса. </a></p>

<h3 align="center"><a name="ref9_18.14.4">14.4 Явные
преобразования указателей </a></h3>

<p><a name="ref9_18.14.4">Определенные
преобразования, включающие
массивы, выполняются, но имеют
зависящие от реализации аспекты.
Все они задаются с помощью явной
операции преобразования типов, см. </a><a
href="ref1_7.htm#ref1_7.7.2">##7.2</a> и <a
href="ref8.htm#ref8.7">8.7.</a> <br>
Указатель может быть преобразован
к любому из целых типов, достаточно
больших для его хранения. То, какой
из int и long требуется, является
машинно зависимым. Преобразующая
функция также является машинно
зависимой, но предполагается, что
она не содержит сюрпризов для того,
кто знает структуру адресации в
машине. Подробности для некоторых
конкретных машин были даны в <a
href="ref1_7.htm#ref1_7.2.6">#2.6.</a> <br>
Объект целого типа может быть явно
преобразован в указатель.
Преобразующая функция всегда
превращает целое, полученное из
указателя, обратно в тот же
указатель, но в остальных случаях
является машинно зависимой. <br>
Указатель на один тип может быть
преобразован в указатель на другой
тип. Использование результирующего
указателя может вызывать особые
ситуации, если исходный указатель
не указывает на объект,
соответствующим образом
выравненный в памяти.
Гарантируется, что указатель на
объект данного размера может быть
преобразован в указатель на объект
меньшего размера и обратно без
изменений. <br>
Например, программа, выделяющая
память, может получать размер (в
байтах) размещаемого объекта и
возвращать указатель на char; это
можно использовать следующим
образом. </p>

<pre>
  extern void* alloc ();
  double* dp;

  dp = (double*) alloc (sizeof (double));
  *dp= 22.0 / 7.0;
</pre>

<p><br>
alloc должна обеспечивать (машинно
зависимым образом) то, что
возвращаемое ею значение подходит
для преобразования в указатель на
double; в этом случае использование
функции мобильно. Различные машины
различаются по числу бит в
указателях и требованиям к
выравниванию объектов. Составные
объекты выравниваются по самой
строгой границе, требуемой
каким-либо из его составляющих. </p>

<h2 align="center"><a name="ref9_18.15">15.
Константные Выражения </a></h2>

<p><a name="ref9_18.15">В нескольких местах C++
требует выражения, вычисление
которых дает константу: в качестве
границы массива (</a><a href="ref8.htm#ref8.3">#8.3</a>),
в case выражениях (<a href="#ref9_18.9.7">#9.7</a>),
в качестве значений параметров
функции, присваиваемых по
умолчанию, (<a href="ref8.htm#ref8.3">#8.3</a>), и в
инициализаторах (<a href="ref8.htm#ref8.6">#8.6</a>).
В первом случае выражение может
включать только целые константы,
символьные константы, константы,
описанные как имена, и sizeof
выражения, возможно, связанные
бинарными операциями </p>

<pre>
   + - * / % &amp; | ^ <<>&gt; == != <> <=>= &amp;&amp; ||
</pre>

<p><br>
или унарными операциями </p>

<pre>
  - ~ !
</pre>

<p><br>
или тернарными операциями </p>

<pre>
  ? :
</pre>

<p><br>
Скобки могут использоваться для
группирования, но не для вызова
функций. <br>
Большая широта допустима для
остальных трех случаев
использования; помимо константных
выражений, обсуждавшихся выше,
допускаются константы с плавающей
точкой, и можно также применять
унарную операцию &amp; к внешним или
статическим объектам, или к внешним
или статическим массивам,
индексированным константным
выражением. Унарная операция &amp;
может также быть применена неявно с
помощью употребления
неиндексированных массивов и
функций. Основное правило состоит в
том, что инициализаторы должны при
вычислении давать константу или
адрес ранее описанного внешнего
или статического объекта плюс или
минус константа. <br. Меньшая широта допустима для константных выражений после #if: константы, описанные как имена, sizeof выражения и перечислимые константы недопустимы. <a name="ref9_18.16"> </p>

<h2 align="center">16. Соображения
Мобильности </h2>

<p>Определенные части C++ являются
машинно зависимыми по своей сути.
Следующий ниже список мест
возможных затруднений не
претендует на полноту, но может
указать на основные из них. <br>
Как показала практика,
характеристики аппаратуры в чистом
виде, такие, как размер слова,
свойства плавающей арифметики и
целого деления, не создают особых
проблем. Другие аппаратные аспекты
отражаются на различных
программных разработках. Некоторые
из них, особенно знаковое
расширение (преобразование
отрицательного символа в
отрицательное целое) и порядок
расположения байтов в слове,
являются досадными помехами, за
которыми надо тщательно следить.
Большинство других являются всего
лишь мелкими сложностями. <br>
Число регистровых переменных,
которые фактически могут быть
помещены в регистры, различается от
машины к машине, как и множество
фактических типов. Тем не менее, все
компиляторы на &quot;своей&quot; машине
все делают правильно; избыточные
или недействующие описания register
игнорируются. <br>
Некоторые сложности возникают при
использовании двусмысленной
манеры программирования. Писать
программы, зависящие от какой-либо
из этих особенностей, районе
неблагоразумно. <br>
В языке не определен порядок
вычисления параметров функции. На
некоторых машинах он слева направо,
а на некоторых справа налево.
Порядок появления некоторых
побочных эффектов также
недетерминирован. <br>
Поскольку символьные константы в
действительности являются
объектами типа int, то могут быть
допустимы многосимвольные
константы. Однако конкретная
реализация очень сильно зависит от
машины, поскольку порядок, в
котором символы присваиваются
слову, различается от машины к
машине. На некоторых машинах поля в
слове присваиваются слева направо,
на других справа налево. <br>
Эти различия невидны для отдельных
программ, не позволяющих себе
каламбуров с типами (например,
преобразования int указателя в char
указатель и просмотр памяти, на
которую указывает указатель), но
должны приниматься во внимание при
согласовании внешне предписанных
форматов памяти. </p>

<h2 align="center"><a name="ref9_18.17">17. Свободная
Память </a></h2>

<p><a name="ref9_18.17">Операция new (</a><a
href="ref1_7.htm#ref1_7.7.2">#7.2</a>) вызывает
функцию </p>

<pre>
  extern void* _new (long);
</pre>

<p><br>
для получения памяти. Параметр
задает число требуемых байтов.
Память будет инициализирована.
Если _new не может найти требуемое
количество памяти, то она
возвращает ноль. <br>
Операция delete вызывает функцию </p>

<pre>
   extern void _delete (void*);
</pre>

<p><br>
чтобы освободить память, указанную
указателем, для повторного
использования. Результат вызова
_delete() для указателя, который не был
получен из _new(), не определен, это же
относится и к повторному вызову
_delete() для одного и того же
указателя. Однако уничтожение с
помощью delete указателя со значением
ноль безвредно. <br>
Предоставляются стандартные
версии _new() и _delete(), но пользователь
может применять другие, более
подходящие для конкретных
приложений. <br>
Когда с помощью операции new
создается классовый объект, то для
получения необходимой памяти
конструктор будет (неявно)
использовать new. Конструктор может
осуществить свое собственное
резервирование памяти посредством
присваивания указателю this до
каких-либо использований. С помощью
присваивания this значения ноль
деструктор может избежать
стандартной операции
дерезервирования памяти для
объекта его класса. Например: </p>

<pre>
  class cl
    {
      int v[10];
      cl () { this = my_own_allocator (sizeof (cl)); }
      ~cl () { my_own_deallocator (this); this = 0; }
    }
</pre>

<p><br>
На входе в конструктор this является
не-нулем, если резервирование
памяти уже имело место (как это
имеет место для автоматических
объектов), и нулем в остальных
случаях. <br>
Если производный класс
осуществляет присваивание this, то
вызов конструктора (если он есть)
базового класса будет иметь место
после присваивания, так что
конструктор базового класса
ссылаться на объект посредством
конструктора производного класса.
Если конструктор базового класса
осуществляет присваивание this, то
значение также будет
использоваться конструктором (если
таковой есть) производного класса. </p>

<h2 align="center"><a name="ref9_18.18">18. Краткое
Изложение Синтаксиса </a></h2>

<p><a name="ref9_18.18">Мы надеемся, что эта
краткая сводка синтаксиса C++
поможет пониманию. Она не является
точным изложением языка. </a></p>

<h3 align="center"><a name="ref9_18.18.1">18.1 Выражения
</a></h3>

<pre><a name="ref9_18.18.1">
     выражение:
          терм
          выражение           бинарная_операция           выражение
          выражение       ?       выражение       :       выражение
          список_выражений
     терм:
          первичный
          *                                                    терм
          &amp;                                                    терм
          -                                                    терм
          !                                                    терм
          ~                                                    терм
          ++терм
          --терм
          терм++
          терм--
          (                   имя_типа)                   выражение
          имя_простого_типа           (           список_выражений)
          sizeof                                          выражение
          sizeof             (              имя_типа              )
          new                                              имя_типа
          new ( имя_типа )
     первичный:
          id
          ::                                          идентификатор
          константа
          строка
          this
          (                       выражение                       )
          первичный[                  выражение                   ]
          первичный      (       список_выражений       opt       )
          первичный.id
          первичный-&gt;id
     id:
          идентификатор
          typedef-имя :: идентификатор
     список_выражений:
          выражение
          список_выражений, выражение
     операция:
          унарная_операция
          бинарная_операция
          специальная_операция
  Бинарные операции имеют приоритет, убывающий в указанном порядке:
     бинарная_операция:
          *                          /                            %
          +                                                       -
          <<>&gt;
          <>
          ==                                                     !=
          &amp;
          ^
          |
          &amp;&amp;
          ||
          =   +=  -=  *=  /=  %=  ^=  &amp;=  |=  &gt;&gt;=  <<= унарная_операция: * & ~ ! ++ специальная_операция: () [] имя_типа: спецификаторы_описания абстрактный_описатель абстрактный_описатель: пустой * абстрактный_описатель абстрактный_описатель ( список_описаний_параметров ) абстрактный_описатель [ константное_выражение opt ] ( абстрактный_описатель ) простое_имя_типа: typedef-имя char short int long unsigned float double typedef-имя: идентификатор </pre>
</a><a name="ref9_18.18.2">
</a></pre>

<h3 align="center"><a name="ref9_18.18.2">18.2 Описания </a></h3>

<pre><a name="ref9_18.18.2">
     описание:
          спецификаторы_описания  opt   список_описателей   opt   ;
          описание_имени
          asm-описание
     описание_имени:
          агрег                   идентификатор                   ;
          enum  идентификатор ;
     агрег:
          class
          struct
          union
     asm-описание:
          asm ( строка );
     спецификаторы_описания:
          спецификатор_описания спецификатор_описания opt
     спецификатор_описания:
          имя_простого_типа
          спецификатор_класса
          enum_спецификатор
          sc_спецификатор
          фнк_спецификатор
          typedef
          friend
          const
          void
     sc_спецификатор:
          auto
          extern
          register
          static
     фнк-спецификатор:
          inline
          overload
          virtual
     список_описателей:
          иниц-описатель
          иниц-описатель , список_описателей
     иниц-описатель:
          описатель инициализатор opt
     описатель:
          оп_имя
          (                       описатель                       )
          *             const             opt             описатель
          &amp;             const             opt             описатель
          описатель      (       список_описаний_параметров       )
          описатель [ константное_выражение opt ]
     оп_имя:
          простое_оп_имя
          typedef-имя . простое_оп_имя
     простое_оп_имя:
          идентификатор
          typedef-имя
          -                                             typedef-имя
          имя_функции_операции
     имя_функции_операции:
          операция операция
     список_описаний_параметров:
          список_описаний_прм opt ... opt
     список_описаний_прм                                          :
          список_описаний_прм         ,          описание_параметра
          описание_параметра
     описание_параметра:
          спецификаторы_описания                          описатель
          спецификаторы_описания описатель = константное_выражение
     спецификатор_класса:
          заголовок_класса       {список_членов        opt        }
          заголовок_класса    {список_членов     opt    public    :
     список_членов opt }
     заголовок_класса                                             :
          агрег                  идентификатор                  opt
          агрег идентификатор opt : public opt typedef-имя
     список_членов                                                :
          описание_члена список_членов opt
     описание_члена:
          спецификаторы_описания opt описатель_члена ;
     описатель_члена:
          описатель
          идентификатор opt : константное_выражение
     инициализатор:
          =                                               выражение
          =                {                список_инициализаторов}
          =       {        список_инициализаторов,                }
          (список_выражений )
     список_инициализаторов                                       :
          выражение
          список_инициализаторов        ,    список_инициализаторов
          { список_инициализаторов }
     enum-спецификатор:
          enum идентификатор opt { enum-список }
     enum-список:
          перечислитель
          enum-список , перечислитель
     перечислитель:
          идентификатор
          идентификатор = константное_выражение
</a></pre>

<h3 align="center"><a name="ref9_18.18.3">18.3 Операторы
</a></h3>

<pre><a name="ref9_18.18.3">
     составной_оператор:
          { список_описаний opt список_операторов opt }
     список_описаний:
          описание
          описание список_описаний
     список_операторов:
          оператор
          оператор список_операторов
     оператор:
          выражение                                               ;
          if         (         выражение         )         оператор
          if    (    выражение    )    оператор    else    оператор
          while        (         выражение        )        оператор
          do     оператор     while     (     выражение     )     ;
          for (  выражение opt  ; выражение  opt ;  выражение opt )
               оператор
          switch        (        выражение        )        оператор
          case      константное      выражение      :      оператор
          default                    :                     оператор
          break;
          continue;
          return            выражение             opt             ;
          goto                   идентификатор                    ;
          идентификатор                 :                  оператор
          delete                    выражение                     ;
          asm           (            строка           )           ;
          ;
</a></pre>

<h3 align="center"><a name="ref9_18.18.4">18.4 Внешние
определения </a></h3>

<pre><a name="ref9_18.18.4">
     программа:
          внешнее_определение
          внешнее_определение программа
     внешнее_определение:
          определение_функции
          описание
     определение_функции:
          спецификаторы_описания       opt        описатель_функции
     инициализатор_базового_класса opt тело_функции
     описатель_функции:
          описатель ( список_описаний_параметров)
     тело_функции:
          составной_оператор
     инициализатор_базового_класса:
          : ( список_параметров opt )
</a></pre>

<h3 align="center"><a name="ref9_18.18.5">18.5
Препроцессор </a></h3>

<pre><a name="ref9_18.18.5">
     #define идент строка_символов
     #define идент( идент,...,идент ) строка символов
     #else
     #endif
     #if выражение
     #ifdef идент
     #ifndef идент
     #include &quot;имя_файла&quot;
     #include <имя_файла>
     #line константа &quot;имя_файла&quot;
     #undef идент
</a></pre>

<h2 align="center"><a name="ref9_18.19">19. Отличия от
&quot;старого C&quot; </a></h2>

<h3 align="center"><a name="ref9_18.19.1">19.1
Расширения </a></h3>

<p><a name="ref9_18.19.1">Типы параметров
функции могут быть заданы (</a><a
href="ref8.htm#ref8.4">#8.4</a>) и будут
проверяться (<a href="ref1_7.htm#ref1_7.7.1">#7.1</a>).
Могут выполняться преобразования
типов. <br>
Для выражений с числами с плавающей
точкой может использоваться
плавающая арифметика одинарной
точности; <a href="ref1_7.htm#ref1_7.6.2">#6.2.</a> <br>
Имена функций могут быть
перегружены; <a href="ref8.htm#ref8.6">#8.6</a> <br>
Операции могут быть перегружены; <a
href="ref1_7.htm#ref1_7.7.16">#7.16</a>, <a
href="ref8.htm#ref8.5.10">#8.5.10.</a> <br>
Может осуществляться
inline-подстановка функций; <a
href="ref8.htm#ref8.1">#8.1.</a> <br>
Объекты данных могут быть
константными (const); <a href="ref8.htm#ref8.3">#8.3.</a>
<br>
Могут быть описаны объекты
ссылочного типа; <a href="ref8.htm#ref8.3">#8.3</a>,
<a href="ref8.htm#ref8.6.3">#8.6.3</a> <br>
Операции new и delete обеспечивают
свободное хранение в памяти; #17. <br>
Класс может обеспечивать скрытые
данные (<a href="ref8.htm#ref8.5.8">#8.5.8</a>),
гарантированную инициализацию (<a
href="ref8.htm#ref8.6.2">#8.6.2</a>), определяемые
пользователем преобразования (<a
href="ref8.htm#ref8.5.6">#8.5.6</a>), и динамическое
задание типов через использование
виртуальных функций (<a
href="ref8.htm#ref8.5.4">#8.5.4</a>). <br>
Имя класса является именем типа; <a
href="ref8.htm#ref8.5">#8.5.</a> <br>
Любой указатель может
присваиваться [указателю] void* без
приведения типов; <a href="ref1_7.htm#ref1_7.7.14">#7.14.</a>
</p>

<p align="center"><font size="2">[</font><a href="ref8.htm"><font
size="2">Назад</font></a><font size="2">] [</font><a
href="aglav.htm"><font size="2">Содержание</font></a><font
size="2">] </font></p>

<p align="center">&nbsp;</p>
</body>
</html>
