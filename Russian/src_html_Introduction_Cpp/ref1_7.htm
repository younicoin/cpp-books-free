<htm>
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Бьярн Страустрап. Справочное руководство по Си++</title>
</head>

<body bgcolor="#FFF5EE" link="#FF0000" vlink="#A52A2A"
alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h2 align="center"><a name="ref1_7.1">1. Введение </a></h2>

<p><a name="ref1_7.1">Язык программирования
C++ - это C</a><a href="#ref1_7*1">*<sup>1</sup></a>,
расширенный введением классов,
inline-функций, перегруженных
операций, перегруженных имен
функций, константных типов, ссылок,
операций управления свободной
памятью, проверки параметров
функций. Коротко различия между С++
и &quot;старым С&quot; приведены в <a
href="ref9_18.htm#ref9_18.15">#15.</a> В этом
руководстве описывается язык по
состоянию на Июнь 1985. </p>

<h2 align="center"><a name="ref1_7.2">2.
Договоренности о Лексике </a></h2>

<p><a name="ref1_7.2">Есть шесть классов
лексем: идентификаторы, ключевые
слова, константы, строки, операторы
и прочие разделители. Символы
пробела, табуляции и новой строки, а
также комментарии (собирательно -
&quot;белые места&quot;), как описано
ниже, игнорируются, за исключением
тех случаев, когда они служат
разделителями лексем. Некое пустое
место необходимо для разделения
идентификаторов, ключевых слов и
констант, которые в противном
случае окажутся соприкасающимися. <br>
Если входной поток разобран на
лексемы до данного символа,
принимается, что следующая лексема
содержит наиболее длинную строку
символов из тех, что могут
составить лексему. </a></p>

<h3 align="center"><a name="ref1_7.2.1">2.1
Комментарии </a></h3>

<p><a name="ref1_7.2.1">Символы /* задают
начало комментария,
заканчивающегося символами */.
Комментарии не могут быть
вложенными. Символы // начинают
комментарий, который заканчивается
в конце строки, на которой они
появились. </a></p>

<h3 align="center"><a name="ref1_7.2.2">2.2
Идентификаторы (имена) </a></h3>

<p><a name="ref1_7.2.2">Идентификатор -
последовательность букв и цифр
произвольной длины; первый символ
обязан быть буквой; подчерк '_'
считается за букву; буквы в верхнем
и нижнем регистрах являются
различными. </a></p>

<h3 align="center"><a name="ref1_7.2.3">2.3 Ключевые
слова </a></h3>

<p><a name="ref1_7.2.3">Следующие
идентификаторы зарезервированы
для использования в качестве
ключевых слов и не могут
использоваться иным образом: </a></p>

<pre><a name="ref1_7.2.3">
  asm       auto      break     case      char
  class     const     continue  default   delete
  do        double    else      enum      extern
  float     for       friend    goto      if
  inline    int       long      new       operator
  overload  public    register  return    short
  sizeof    static    struct    switch    this
  typedef   union     unsigned  virtual   void
  while
</a></pre>

<p><a name="ref1_7.2.3"><br>
Идентификаторы signed и volatile
зарезервированы для применения в
будущем. </a></p>

<h3 align="center"><a name="ref1_7.2.4">2.4 Константы </a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref1_7.2.4"></a>&nbsp;</td>
        <td><a href="#ref1_7.2.4.1">2.4.1 Целые
        константы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.2.4.2">2.4.2 Явно
        заданные длинные константы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.2.4.3">2.4.3 Символьные
        константы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.2.4.4">2.4.4 Константы с
        плавающей точкой </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.2.4.5">2.4.5
        Перечислимые константы </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.2.4.6">2.4.6 Описанные
        константы </a></td>
    </tr>
</table>

<p>Как описано ниже, есть несколько
видов констант. В <a href="#ref1_7.2.6">#2.6</a>
приводится краткая сводка
аппаратных характеристик, которые
влияют на их размеры. </p>

<h4 align="center"><a name="ref1_7.2.4.1">2.4.1 Целые
константы </a></h4>

<p><a name="ref1_7.2.4.1">Целая константа,
состоящая из последовательности
цифр, считается восьмиричной, если
она начинается с 0 (цифры ноль), и
десятичной в противном случае.
Цифры 8 и 9 не являются
восьмиричными цифрами.
Последовательность цифр, которой
предшествует 0х или 0Х,
воспринимается как
шестнадцатеричное целое. В
шестнадцатеричные цифры входят
буквы от а или А до f или F, имеющие
значения от 10 до 15. Десятичная
константа, значение которой
превышает наибольшее машинное
целое со знаком, считается длинной
(long); восьмеричная и
шестнадцатеричная константа,
значение которой превышает
наибольшее машинное целое со
знаком, считается long; в остальных
случаях целые константы считаются
int. </a></p>

<h4 align="center"><a name="ref1_7.2.4.2">2.4.2 Явно
заданные длинные константы </a></h4>

<p><a name="ref1_7.2.4.2">Десятичная,
восьмиричная или
шестнадцатиричная константа, за
которой непосредственно стоит l
(латинская буква &quot;эль&quot;) или L,
считается длинной константой. </a></p>

<h4 align="center"><a name="ref1_7.2.4.3">2.4.3
Символьные константы</a></h4>

<p><a name="ref1_7.2.4.3">Символьная константа
состоит из символа, заключенного в
одиночные кавычки (апострофы), как,
например, 'х'. Значением символьной
константы является численное
значение символа в машинном наборе
символов (алфавите). Символьные
константы считаются данными типа
int. <br>
Некоторые неграфические символы,
одиночная кавычка ' и обратная
косая \, могут быть представлены в
соответствие со следующей таблицей
escape-последовательностей: </a></p>

<table border="0">
    <tr>
        <td><a name="ref1_7.2.4.3">символ новой
        строки </a></td>
        <td><a name="ref1_7.2.4.3">NL(LF) </a></td>
        <td><a name="ref1_7.2.4.3">\n </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">горизонтальная
        табуляция </a></td>
        <td><a name="ref1_7.2.4.3">NT </a></td>
        <td><a name="ref1_7.2.4.3">\t </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">вертикальная
        табуляция </a></td>
        <td><a name="ref1_7.2.4.3">VT </a></td>
        <td><a name="ref1_7.2.4.3">\v </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">возврат на шаг </a></td>
        <td><a name="ref1_7.2.4.3">BS </a></td>
        <td><a name="ref1_7.2.4.3">\b </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">возврат каретки </a></td>
        <td><a name="ref1_7.2.4.3">CR </a></td>
        <td><a name="ref1_7.2.4.3">\r </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">перевод формата </a></td>
        <td><a name="ref1_7.2.4.3">FF </a></td>
        <td><a name="ref1_7.2.4.3">\f </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">обратная косая </a></td>
        <td><a name="ref1_7.2.4.3">\ </a></td>
        <td><a name="ref1_7.2.4.3">\\ </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">одиночная
        кавычка (апостроф) </a></td>
        <td><a name="ref1_7.2.4.3">' </a></td>
        <td><a name="ref1_7.2.4.3">\' </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">набор битов </a></td>
        <td><a name="ref1_7.2.4.3">0ddd </a></td>
        <td><a name="ref1_7.2.4.3">\ddd </a></td>
    </tr>
    <tr>
        <td><a name="ref1_7.2.4.3">набор битов </a></td>
        <td><a name="ref1_7.2.4.3">0xddd </a></td>
        <td><a name="ref1_7.2.4.3">\xddd </a></td>
    </tr>
</table>

<p><a name="ref1_7.2.4.3"><br>
Escape-последовательность \ddd состоит
из обратной косой, за которой
следуют 1, 2 или 3 восьмеричных цифры,
задающие значение требуемого
символа. Специальным случаем такой
конструкции является \0 (не следует
ни одной цифры), задающая пустой
символ NULL. Escape-последовательность
\xddd состоит из обратной косой, за
которой следуют 1, 2 или 3
шестнадцатиричных цифры, задающие
значение требуемого символа. Если
следующий за обратной косой символ
не является одним из перечисленных,
то обратная косая игнорируется. </a></p>

<h4 align="center"><a name="ref1_7.2.4.4">2.4.4
Константы с плавающей точкой </a></h4>

<p><a name="ref1_7.2.4.4">Константа с
плавающей точкой состоит из целой
части, десятичной точки, мантиссы, е
или Е и целого показателя степени
(возможно, но не обязательно, со
знаком). Целая часть и мантисса обе
состоят из последовательности
цифр. Целая часть или мантисса (но
не обе сразу) может быть опущена;
или десятичная точка, или е(Е)
вместе с целым показателем степени
(но не обе части одновременно) может
быть опущена. Константа с плавающей
точкой имеет тип double. </a></p>

<h4 align="center"><a name="ref1_7.2.4.5">2.4.5
Перечислимые константы </a></h4>

<p><a name="ref1_7.2.4.5">Имена, описанные как
перечислители, (см. #8.5) являются
константами типа int. </a></p>

<h4 align="center"><a name="ref1_7.2.4.6">2.4.6
Описанные константы </a></h4>

<p><a name="ref1_7.2.4.6">Объект (</a><a href="#ref1_7.5">#5</a>)
любого типа может быть определен
как имеющий постоянное значение во
всей области видимости (<a href="#ref1_7.4.1">#4.1</a>)
его имени. В случае указателей для
достижения этого используется
декларатор *const; для объектов, не
являющихся указателями,
используется описатель const (<a
href="ref8.htm#ref8.2">#8.2</a>). </p>

<h3 align="center"><a name="ref1_7.2.5">2.5 Строки </a></h3>

<p><a name="ref1_7.2.5">Строка есть
последовательность символов,
заключенная в двойные кавычки:
&quot;...&quot;. Строка имеет тип
&quot;массив символов&quot; и класс
памяти static (см. </a><a href="#ref1_7.4">#4</a>),
она инициализируется заданными
символами. Все строки, даже если они
записаны одинаково, различны.
Компилятор располагает в конце
каждой строки нулевой (пустой) байт
\0 с тем, чтобы сканирующая строку
программа могла найти ее конец. В
строке перед символом двойной
кавычки &quot; обязательно должен
стоять \; кроме того, могут
использоваться те же
escape-последовательности, что были
описаны для символьных констант. И,
наконец, символ новой строки может
появляться только сразу после \;
тогда оба, - \ и символ новой строки, -
игнорируются. </p>

<h3 align="center"><a name="ref1_7.2.6">2.6
Характеристики аппаратного
обеспечения</a></h3>

<p><a name="ref1_7.2.6">В нижеследующей
таблице собраны некоторые
характеристики аппаратного
обеспечения, различающиеся от
машины к машине. </a></p>

<pre><a name="ref1_7.2.6">
_____________________________________________________________
|           DEC VAX-11 Motorola 68000 IBM 370     AT&amp;T 3B   |
|            ASCII        ASCII       EBCDIC       ASCII    |
|___________________________________________________________|
| char     |    8 бит  |   8 бит   |  8 бит    |   8 бит    |
| int      |   32 бит  |  16 бит   | 32 бит    |  16 бит    |
| short    |   16 бит  |  16 бит   | 16 бит    |  16 бит    |
| long     |   32 бит  |  32 бит   | 32 бит    |  32 бит    |
| float    |   32 бит  |  32 бит   | 32 бит    |  32 бит    |
| double   |   64 бит  |  64 бит   | 64 бит    |  64 бит    |
| указатель|   32 бит  |  32 бит   | 24 бит    |  32 бит    |
| диапазон |           |           |           |            |
|    float | +_10E+_38 | +_10E+_38 | +_10E+_76 | +_10E+_38  |
| диапазон |           |           |           |            |
|   double | +_10E+_38 | +_10E+_38 | +_10E+_76 | +_10E+_308 |
| тип char |  знаковый | без знака | без знака | без знака  |
| тип поля |  знаковый | без знака | без знака | без знака  |
| порядок  |  справа   | слева     |  слева    | слева      |
|  полей   |   налево  |  направо  |   направо |  направо   |
|__________|___________|___________|___________|____________|
</a></pre>

<h2 align="center"><a name="ref1_7.3">3. Запись
Синтаксиса</a></h2>

<p><a name="ref1_7.3">По используемым в
данном руководстве синтаксическим
правилам записи синтаксические
категории выделяются курсивом а
литеральные слова и символы
шрифтом постоянной ширины</a><a
href="#ref1_7*2">*<sup>2</sup> </a>. Альтернативные
категории записываются на разных
строках. Необязательный
терминальный или нетерминальный
символ обозначается нижним
индексом &quot;opt&quot;, так что </p>

<pre>
  { выражение opt }
</pre>

<p><br>
указывает на необязательность
выражения в фигурных скобках.
Синтаксис кратко изложен в <a
href="ref9_18.htm#ref7_18.14">#14</a>. </p>

<h2 align="center"><a name="ref1_7.4">4. Имена и Типы </a></h2>

<p><a name="ref1_7.4">Имя обозначает
(денотирует) объект, функцию, тип,
значение или метку. Имя вводится в
программе описанием (</a><a href="ref8.htm">#8</a>).
Имя может использоваться только
внутри области текста программы,
называемой его областью видимости.
Имя имеет тип, определяющий его
использование. Объект - это область
памяти. Объект имеет класс памяти,
определяющий его время жизни. Смысл
значения, обнаруженного в объекте,
определяется типом имени,
использованного для доступа к нему.
</p>

<h3 align="center"><a name="ref1_7.4.1">4.1 Область
видимости </a></h3>

<p><a name="ref1_7.4.1">Есть четыре вида
областей видимости: локальная,
файл, программа и класс. </a></p>

<table border="0">
    <tr>
        <td><a name="ref1_7.4.1">Локальная:</a></td>
        <td><a name="ref1_7.4.1">Имя, описанное в
        блоке (</a><a href="ref9_18.htm#ref9_18.9.2">#9.2</a>),
        локально в этом блоке и может
        использоваться только в нем
        после места описания и в
        охватываемых блоках.
        Исключение составляют метки (<a
        href="ref9_18.htm#ref9_18.9.12">#9.12</a>),
        которые могут использоваться в
        любом месте функции, в которой
        они описаны. Имена формальных
        параметров функции
        рассматриваются так, как если
        бы они были описаны в самом
        внешнем блоке этой функции.</td>
    </tr>
    <tr>
        <td>Файл:</td>
        <td>Имя, описанное вне любого
        блока (<a href="ref9_18.htm#ref9_18.9.2">#9.2</a>)
        или класса (<a href="ref8.htm#ref8.5">#8.5</a>),
        может использоваться в файле,
        где оно описано, после места
        описания.</td>
    </tr>
    <tr>
        <td>Класс:</td>
        <td>Имя члена класса локально
        для его класса и может
        использоваться только в
        функции члене этого класса (<a
        href="ref8.htm#ref8.5.2">#8.5.2</a>), после
        примененной к объекту его
        класса (<a href="#ref1_7.1">#7.1</a>)
        операции . или после
        примененной к указателю на
        объект его класса (<a href="#ref1_7.1">#7.1</a>)
        операции -&gt;. На статические
        члены класса (<a href="ref8.htm#ref8.5.1">#8.5.1</a>)
        и функции члены можно также
        ссылаться с помощью операции ::
        там, где имя их класса
        находится в области видимости.
        Класс, описанный внутри класса
        (<a href="ref8.htm#ref8.5.15">#8.5.15</a>), не
        считается членом, и его имя
        принадлежит охватывающей
        области видимости.</td>
    </tr>
</table>

<p><br>
Имя может быть скрыто посредством
явного описания того же имени в
блоке или классе. Имя в блоке или
классе может быть скрыто только
именем, описанным в охватываемом
блоке или классе. Скрытое
нелокальное имя также может
использоваться, когда его область
видимости указана операцией :: (<a
href="#ref1_7.1">#7.1</a>). Имя класса, скрытое
именем, которое не является именем
типа, все равно может
использоваться, если перед ним
стоит class, struct или union (<a href="ref8.htm#ref8.2">#8.2</a>).
Имя перечисления enum, скрытое
именем, которое не является именем
типа, все равно может
использоваться, если перед ним
стоит enum (<a href="ref8.htm#ref8.2">#8.2</a>). </p>

<h3 align="center"><a name="ref1_7.4.2">4.2
Определения</a></h3>

<p><a name="ref1_7.4.2">Описание (</a><a href="ref8.htm">#8</a>)
является определением, за
исключением тех случаев, когда оно
описывает функции, не задавая тела
функции (<a href="ref9_18.htm#ref9_18.10">#10</a>),
когда оно содержит спецификатор
extern (1) и в нем нет инициализатора
или тела функции, или когда оно
является описанием класса (<a
href="ref8.htm#ref8.8">#8.8</a>). </p>

<h3 align="center"><a name="ref1_7.4.3">4.3 Компоновка </a></h3>

<p><a name="ref1_7.4.3">Имя в файловой области
видимости, не описанное явно как
static, является общим для каждого
файла многофайловой программы.
Таковым же является имя функции. О
таких именах говорится, что они
внешние. Каждое описание внешнего
имени в программе относится к тому
же объекту (</a><a href="#ref1_7.5">#5</a>),
функции (<a href="ref8.htm#ref8.7">#8.7</a>), классу
(<a href="ref8.htm#ref8.5">#8.5</a>), перечислению (<a
href="ref8.htm#ref8.10">#8.10 </a>) или значению
перечислителя (<a href="ref8.htm#ref8.10">#8.10</a>).
<br>
Типы, специфицированные во всех
описаниях внешнего имени должны
быть идентичны. Может быть больше
одного определения типа,
перечисления, inline-функции (<a
href="ref8.htm#ref8.1">#8.1</a>) или несоставного
const (<a href="ref8.htm#ref8.2">#8.2</a>), при
условии, что определения идентичны,
появляются в разных файлах и все
инициализаторы являются
константными выражениями (<a
href="ref9_18.htm#ref9_18.12">#12</a>). Во всех
остальных случаях должно быть
ровно одно определение для
внешнего имени в программе. <br>
Реализация может потребовать,
чтобы составное const, использованное
там, где не встречено никакого
определения const, должно быть явно
описано extern и иметь в программе
ровно одно определение. Это же
ограничение может налагаться на
inline-функции. </p>

<h3 align="center"><a name="ref1_7.4.4">4.4 Классы
памяти</a></h3>

<p><a name="ref1_7.4.4">Есть два описываемых
класса памяти: автоматический и
статический. </a></p>

<p><a name="ref1_7.4.4">Автоматические
объекты локальны для каждого
вызова блока и сбрасываются по
выходе из него. </a></p>

<p><a name="ref1_7.4.4">Статические объекты
существуют и сохраняют свое
значение в течение выполнения всей
программы. </a></p>

<p><a name="ref1_7.4.4">Некоторые объекты не
связаны с именами и их времена
жизни явно управляются операторами
new и delete ; см. </a><a href="#ref1_7.7.2">#7.2 и </a><a
href="ref9_18.htm#ref9_18">#9.14</a> </p>

<h3 align="center"><a name="ref1_7.4.5">4.5 Основные
типы </a></h3>

<p><a name="ref1_7.4.5">Объекты, описанные как
символы (char), достаточны для
хранения любого элемента машинного
набора символов, и если
принадлежащий этому набору символ
хранится в символьной переменной,
то ее значение равно целому коду
этого символа. <br>
В настоящий момент имеются целые
трех размеров, описываемые как short
int, int и long int. Более длинные целые (long
int) предоставляют не меньше памяти,
чем более короткие целые (short int), но
при реализации или длинные, или
короткие, или и те и другие могут
стать эквивалентными обычным
целым. &quot;Обычные&quot; целые имеют
естественный размер, задаваемый
архитектурой центральной машины;
остальные размеры делаются такими,
чтобы они отвечали специальным
потребностям. <br>
Каждое перечисление (</a><a
href="ref8.htm#ref8.9">#8.9</a>) является набором
именованных констант. Свойства enum
идентичны свойствам int. <br>
Целые без знака, описываемые как
unsigned, подчиняются правилам
арифметики по модулю 2n, где n - число
бит в их представлении. <br>
Числа с плавающей точкой одинарной
(float) и двойной (double) точности в
некоторых машинных реализациях
могут быть синонимами. <br>
Поскольку объекты перечисленных
выше типов вполне можно
интерпретировать как числа, мы
будем говорить о них как об
арифметических типах. Типы char, int
всех размеров и enum будут
собирательно называться целыми
типами. Типы float и double будут
собирательно называться
плавающими типами. <br>
Тип данных void (пустой) определяет
пустое множество значений.
Значение (несуществующее) объекта
void нельзя использовать никаким
образом, не могут применяться ни
явное, ни неявное преобразования.
Поскольку пустое выражение
обозначает несуществующее
значение, такое выражение такое
выражение может использоваться
только как оператор выражение (<a
href="ref9_18.htm#ref9_18.9.1">#9.1</a>) или как левый
операнд в выражении с запятой (<a
href="#ref1_7.7.15">#7.15</a>). Выражение может
явно преобразовываться к типу void (<a
href="#ref1_7.7.2">#7.2</a>). </p>

<h3 align="center"><a name="ref1_7.4.4">4.4
Производные типы </a></h3>

<p><a name="ref1_7.4.4">Кроме основных
арифметических типов
концептуально существует
бесконечно много производных
типов, сконструированных из
основных типов следующим образом: </a></p>

<ul>
    <li><a name="ref1_7.4.4">массивы объектов
        данного типа; </a></li>
    <li><a name="ref1_7.4.4">функции, получающие
        аргументы данного типа и
        возвращающие объекты данного
        типа; </a></li>
    <li><a name="ref1_7.4.4">указатели на
        объекты данного типа; </a></li>
    <li><a name="ref1_7.4.4">ссылки на объекты
        данного типа; </a></li>
    <li><a name="ref1_7.4.4">константы,
        являющиеся значениями данного
        типа; </a></li>
    <li><a name="ref1_7.4.4">классы, содержащие
        последовательность объектов
        различных типов, множество
        функций для работы с этими
        объектами и набор ограничений
        на доступ к этим объектам и
        функциям; структуры,
        являющиеся классами без
        ограничений доступа; </a></li>
    <li><a name="ref1_7.4.4">объединения,
        являющиеся структурами,
        которые могут в разное время
        содержать объекты разных
        типов. </a></li>
</ul>

<p><a name="ref1_7.4.4"><br>
В целом эти способы
конструирования объектов могут
применяться рекурсивно. <br>
Объект типа void* (указатель на void)
можно использовать для указания на
объекты неизвестного типа. </a></p>

<h2 align="center"><a name="ref1_7.5">5. Объекты и
lvalue(адреса) </a></h2>

<p><a name="ref1_7.5">Объект есть область
памяти; lvalue (адрес) есть выражение,
ссылающееся на объект. Очевидный
пример адресного выражения - имя
объекта. Есть операции, дающие
адресные выражения: например, если
Е - выражение типа указатель, то *Е -
адресное выражение, ссылающееся на
объект, на который указывает Е.
Термин &quot;lvalue&quot; происходит из
выражения присваивания Е1=Е2, в
котором левый операнд Е1 должен
быть адресным (value) выражением. Ниже
при обсуждении каждого оператора
указывается, требует ли он адресные
операнды и возвращает ли он
адресное значение. </a></p>

<h2 align="center"><a name="ref1_7.6">6.
Преобразования </a></h2>

<p><a name="ref1_7.6">Определенные операции
могут в зависимости от их операндов
вызывать преобразование значения
операнда от одного типа к другому. В
этой части объясняется, каков
ожидаемый результат таких
преобразований. В </a><a href="#ref1_7.6.6">#6.6</a>
содержится краткое описание
преобразований, требуемых наиболее
стандартными операциями; оно будет
дополняться по мере надобности в
процессе обсуждения каждой
операции. В <a href="ref8.htm#ref8.5.6">#8.5.6</a>
описываются преобразования,
определяемые пользователем. </p>

<h3 align="center"><a name="ref1_7.6.1">6.1 Символы и
целые </a></h3>

<p><a name="ref1_7.6.1">Символ или короткое
целое могут использоваться, если
может использоваться целое. Во всех
случаях значение преобразуется к
целому. Преобразование короткого
целого к длинному всегда включает в
себя знаковое расширение; целые
являются величинами со знаком.
Содержат символы знаковый разряд
или нет, является машинно
зависимым; см. </a><a href="#ref1_7.2.6">#2.6</a>.
Более явный тип unsigned char
ограничивает изменение значения от
0 до машинно зависимого максимума. <br>
В машинах, где символы
рассматриваются как имеющие знак
(знаковые), символы множества кода
ASCII являются положительными.
Однако, символьная константа,
заданная восьмеричной esc-
последовательностью подвергается
знаковому расширению и может стать
отрицательным числом; так например,
'\377' имеет значение -1. <br>
Когда длинное целое преобразуется
в короткое или в char, оно урезается
влево; избыточные биты просто
теряются. </p>

<h3 align="center"><a name="ref1_7.6.2">6.2 Float и double </a></h3>

<p><a name="ref1_7.6.2">Для выражений float
могут выполняться действия
арифметики с плавающей точкой
одинарной точности. Преобразования
между числами одинарной и двойной
точности выполняются настолько
математически корректно, насколько
позволяет аппаратура. </a></p>

<h3 align="center"><a name="ref1_7.6.3">6.3 Плавающие и
целые</a></h3>

<p><a name="ref1_7.6.3">Преобразования
плавающих значений в интегральный
тип имеет склонность быть машинно
зависимым. В частности, направление
усечения отрицательных чисел
различается от машины к машине.
Если предоставляемого
пространства для значения не
хватает, то результат не определен. <br>
Преобразование интегрального
значения в плавающий тип
выполняются хорошо. При нехватке в
аппаратной реализации требуемых
бит возникает некоторая потеря
точности. </a></p>

<h3 align="center"><a name="ref1_7.6.4">6.4 Указатели и
целые </a></h3>

<p><a name="ref1_7.6.4">Выражение целого типа
можно прибавить к указателю или
вычесть из него; в таком случае
первый преобразуется, как
указывается при обсуждении
операции сложения. <br>
Можно производить вычитание над
двумя указателями на объекты
одного типа; в этом случае
результат преобразуется к типу int
или long в зависимости от машины; см. </a><a
href="#ref1_7.7.4">#7.4.</a> </p>

<h3 align="center"><a name="ref1_7.6.5">6.5 Unsigned </a></h3>

<p><a name="ref1_7.6.5">Всегда при сочетании
целого без знака и обычного целого
обычное целое преобразуется к типу
unsigned и результат имеет тип unsigned.
Значением является наименьшее
целое без знака, равное целому со
знаком (mod 2**(размер слова)) (т.е. по
модулю 2**(размер слова)). В
дополнительном двоичном
представлении это преобразование
является пустым, и никаких реальных
изменений в двоичном представлении
не происходит. <br>
При преобразовании целого без
знака в длинное значение
результата численно совпадает со
значением целого без знака. Таким
образом, преобразование сводится к
дополнению нулями слева. </a></p>

<h3 align="center"><a name="ref1_7.6.6">6.6
Арифметические преобразования </a></h3>

<p><a name="ref1_7.6.6">Большое количество
операций вызывают преобразования и
дают тип результата одинаковым
образом. Этот стереотип будет
называться &quot;обычным
арифметическим
преобразованием&quot;. </a></p>

<table border="0">
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Во-первых, любые
        операнды типа char, unsigned char или
        short преобразуются к типу int. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Далее, если один
        из операндов имеет тип double, то
        другой преобразуется к типу
        double и тот же тип имеет
        результат. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Иначе, если один
        из операндов имеет тип unsigned long,
        то другой преобразуется к типу
        unsigned long и таков же тип
        результата. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Иначе, если один
        из операндов имеет тип long, то
        другой преобразуется к типу long
        и таков же тип результата. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Иначе, если один
        из операндов имеет тип unsigned, то
        другой преобразуется к типу
        unsigned и таков же тип результата. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.6"></a>&nbsp;</td>
        <td><a name="ref1_7.6.6">Иначе оба
        операнда должны иметь тип int и
        таков же тип результата. </a></td>
    </tr>
</table>

<h3 align="center"><a name="ref1_7.6.7">6.7
Преобразования указателей </a></h3>

<p><a name="ref1_7.6.7">Везде, где указатели
присваиваются, инициализируются,
сравниваются и т.д. могут
выполняться следующие
преобразования. </a></p>

<table border="0">
    <tr>
        <td width="10"><a name="ref1_7.6.7"></a>&nbsp;</td>
        <td><a name="ref1_7.6.7">Константа 0 может
        преобразовываться в указатель,
        и гарантируется, что это
        значение породит указатель,
        отличный от указателя на любой
        объект. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.7"></a>&nbsp;</td>
        <td><a name="ref1_7.6.7">Указатель любого
        типа может преобразовываться в
        void*. </a></td>
    </tr>
    <tr>
        <td width="10"><a name="ref1_7.6.7"></a>&nbsp;</td>
        <td><a name="ref1_7.6.7">Указатель на
        класс может преобразовываться
        в указатель на открытый
        базовый класс этого класса; см. </a><a
        href="ref8.htm#ref8.5.3">#8.5.3.</a> </td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td>Имя вектора может
        преобразовываться в указатель
        на его первый элемент. </td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td>Идентификатор, описанный как
        &quot;функция, возвращающая ...&quot;,
        всегда, когда он не
        используется в позиции имени
        функции в вызове,
        преобразуется в &quot;указатель
        на функцию, возвращающую ...&quot;. </td>
    </tr>
</table>

<h3 align="center"><a name="ref1_7.6.8">6.8
Преобразования ссылок</a></h3>

<p><a name="ref1_7.6.8">Везде, где
инициализируются ссылки, может
выполняться следующее
преобразование. </a></p>

<p><a name="ref1_7.6.8">Ссылка на класс может
преобразовываться в ссылку на
открытый базовый класс этого
класса; см. </a><a href="ref8.htm#ref8.6.3">#8.6.3.</a> </p>

<h2 align="center"><a name="ref1_7.7">7. ВЫРАЖЕНИЯ </a></h2>

<p><a name="ref1_7.7">Приоритет операций в
выражениях такой же, как и порядок
главных подразделов в этом разделе,
наибольший приоритет у первого. Так
например, выражения, о которых
говорится как об операндах
операции + (</a><a href="#ref1_7.7.4">#7.4) - это те
выражения, которые определены в </a><a
href="#ref1_7.7.1">##7.1-7.4.</a>Внутри каждого
подраздела операции имеют
одинаковый приоритет. В каждом
подразделе для рассматриваемых в
нем операций определяется их левая
или правая ассоциативность
(порядок обработки операндов).
Приоритет и ассоциативность всех
операций собран вместе в описании
грамматики в <a href="ref9_18.htm#ref9_18.14">##14.</a>
<br>
В остальных случаях порядок
вычисления выражения не определен.
Точнее, компилятор волен вычислять
подвыражения в том порядке, который
он считает более эффективным, даже
если подвыражения вызывают
побочные эффекты. Порядок
возникновения побочных эффектов не
определен. Выражения, включающие в
себя коммутативные и ассоциативные
операции (*, +, &amp;, |, ^), могут быть
реорганизованы произвольным
образом, даже при наличии скобок;
для задания определенного порядка
вычисления выражения необходимо
использовать явную временную
переменную. <br>
Обработка переполнения и контроль
деления при вычислении выражения
машинно зависимы. В большинстве
существующих реализаций C++
переполнение целого игнорируется;
обработка деления на 0 и всех
исключительных ситуаций с числами
с плавающей точкой различаются от
машины к машине и обычно могут
регулироваться библиотечными
функциями. <br>
Кроме стандартного значения,
описанного в <a href="#ref1_7.7.2">##7.2-7.15</a>,
операции могут быть перегружены<a
href="#ref1_7*3">*<sup>3</sup></a>, то есть, могут
быть заданы их значения для случая
их применения к типам, определяемым
пользователем; см. <a href="#ref1_7.7.16">#7.16.</a>
</p>

<h3 align="center"><a name="ref1_7.7.1">7.1 Основные
выражения </a></h3>

<p><a name="ref1_7.7.1">Основные выражения,
включающие в себя . , -&gt; ,
индексирование и вызовы функций,
группируются слева направо. </a></p>

<pre><a name="ref1_7.7.1">
     список_выражений:
          выражение
          список_выражений , выражение
     id:
          идентификатор
          имя_функции_операции
          typedef-имя               ::                идентификатор
          typedef-имя :: имя_функции_операции
     первичное_выражение:
          id
          ::                                          идентификатор
          константа
          строка
          this
          (                       выражение                       )
          первичное_выражение                [      выражение     ]
          первичное_выражение        (   список_выражений   opt   )
          первичное_выражение                     .              id
          первичное_выражение   -&gt; id
</a></pre>

<p><a name="ref1_7.7.1"><br>
Идентификатор есть первичное
выражение, причем соответственно
описанное (</a><a href="ref8.htm">#8</a>).
Имя_функции_операции есть
идентификатор со специальным
значением; см. <a href="#ref1_7.7.16">#7.16</a> и <a
href="ref8.htm#ref8.5.1">#8.5.1.</a> <br>
Операция ::, за которой следует
идентификатор из файловой области
видимости, есть то же, что и
идентификатор. Это позволяет
ссылаться на объект даже в том
случае, когда его идентификатор
скрыт (<a href="#ref1_7.4.1">#4.1</a>). <br>
Typedef-имя (<a href="ref8.htm#ref8.8">#8.8</a>) , за
которым следует ::, после чего
следует идентификатор, является
первичным выражением. Typedef-имя
должно обозначать класс (<a
href="ref8.htm#ref8.5">#8.5</a>), и идентификатор
должен обозначать член этого
класса. Его тип специфицируется
описанием идентификатора. Typedef-имя
может быть скрыто именем, которое
не является именем типа. В этом
случае typedef-имя все равно может быть
найдено и его можно использовать. <br>
Константа является первичным
выражением. Ее тип должен быть int, long
или double в зависимости от ее формы. <br>
Строка является первичным
выражением. Ее тип - &quot;массив
символов&quot;. Обычно он сразу же
преобразуется в указатель на ее
первый символ (<a href="#ref1_7.6.7">#6.7</a>). <br>
Ключевое слово this является
локальной переменной в теле
функции члена (см. <a href="ref8.htm#ref8.5">#8.5</a>)
. Оно является указателем на объект,
для которого функция была вызвана. <br>
Выражение, заключенное в круглые
скобки, является первичным
выражением, чей тип и значение те
же, что и у незаключенного в скобки
выражения. Наличие скобок не влияет
на то, является выражение lvalue или
нет. <br>
Первичное выражение, за которым
следует выражение в квадратных
скобках, является первичным
выражением. Интуитивный смысл -
индекс. Обычно первичное выражение
имеет тип &quot;указатель на ...&quot;,
индексирующее выражение имеет тип
int и тип результата есть &quot;...&quot;.
Выражение Е1[Е2] идентично (по
определению) выражению *((E1)+(E2)). Все
тонкие места, необходимые для
понимания этой записи, содержатся в
этом разделе вместе с обсуждением в
<a href="#ref1_7.7.1">## 7.1, 7.2 и 7.4</a>,
соответственно, идентификаторов, *
и + ; ниже, в <a href="ref8.htm#ref8.4.2">#8.4.2 </a>приводятся
следствия из этого. <br>
Вызов функции является первичным
выражением, за которым следуют
скобки, содержащие список
(возможно, пустой) разделенных
запятыми выражений, составляющих
фактические параметры для функции.
Первичное выражение должно иметь
тип &quot;функция, возвращающая ...&quot;
или &quot;указатель на функцию,
возвращающую ...&quot;, и результат
вызова функции имеет тип &quot;...&quot;. <br>
Каждый формальный параметр
инициализируется фактическим
параметром (<a href="ref8.htm#ref8.6">#8.6</a>).
Выполняются стандартные (<a
href="#ref1_7.6.6">#6.6-8</a>) и определяемые
пользователем преобразования (<a
href="ref8.htm#ref8.5.6">#8.5.6</a>). Функция может
изменять значения своих формальных
параметров, но эти изменения не
могут повлиять на значения
фактических параметров за
исключением случая, когда
формальный параметр имеет
ссылочный тип. <br>
Функция может быть описана как
получающая меньше или больше
параметров, чем специфицировано в
описании функции (<a href="ref8.htm#ref8.4">#8.4</a>).
Каждый фактический параметр типа
float, для которого нет формального
параметра, преобразуются к типу
double; и, как обычно, имена массивов
преобразуются к указателям.
Порядок вычисления параметров не
определен языком; имейте в виду
различия между компиляторами. <br>
Допустимы рекурсивные вызовы любых
функций. <br>
Первичное выражение, после
которого стоит точка, за которой
следует идентификатор (или
идентификатор, уточненный
typedef-именем с помощью операции ::)
является выражением. Первое
выражение должно быть объектом
класса, а идентификатор должен
именовать член этого класса.
Значением является именованный
член объекта, и оно является
адресным, если первое выражение
является адресным. Следует
отметить, что &quot;классовые
объекты&quot; могут быть структурами (<a
href="ref8.htm#ref8.5.12">#8.5.12</a>) или
объединениями (<a href="ref8.htm#ref8.5.13">#8.5.13</a>).
<br>
Первичное выражение, после
которого стоит стрелка ( -&gt; ), за
которой следует идентификатор (или
идентификатор, уточненный
typedef-именем с помощью операции ::)
является выражением. Первое
выражение должно быть указателем
на объект класса, а идентификатор
должен именовать член этого класса.
Значение является адресом,
ссылающимся на именованный член
класса, на который указывает
указательное выражение. Так,
выражение E1-&gt;MOS есть то же, что и
(*E1).MOS. Классы обсуждаются в <a
href="ref8.htm#ref8.5">#8.5.</a> <br>
Если первичное выражение дает
значение типа &quot;указатель на ...&quot;
(см. <a href="ref8.htm#ref8.4">#8.4</a> и <a
href="ref8.htm#ref8.6.3">#8.6.3</a>), значением
выражения был объект, обозначаемый
ссылкой. Ссылку можно считать
именем объекта; см. <a href="ref8.htm#ref8.6.3">#8.6.3.</a>
</p>

<h3 align="center"><a name="ref1_7.7.2">7.2 Унарные
операции </a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref1_7.7.2"></a>&nbsp;</td>
        <td><a href="#ref1_7.7.2.1">7.2.1 Увеличение и
        Уменьшение </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.7.2.2">7.2.2 Sizeof </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.7.2.3">7.2.3 Явное
        Преобразование Типа </a></td>
    </tr>
    <tr>
        <td width="10">&nbsp;</td>
        <td><a href="#ref1_7.7.2.4">7.2.4 Свободная
        Память</a> </td>
    </tr>
</table>

<p>Выражения с унарными операциями
группируют справа налево: </p>

<pre>
     унарное_выражение:
          унарная_операция                                выражение
          выражение                                              ++
          выражение                                              --
          sizeof                                          выражение
          sizeof             (              имя_типа              )
          (            имя_типа             )             выражение
          простое_имя_типа       (        список_выражений        )
          new               имя_типа       инициализатор        opt
          new              (               имя_типа               )
          delete                                          выражение
          delete [ выражение ] выражение
     унарная_операция:                   одна                    из
          *  &amp;  -  !  ~  ++  --
</pre>

<p><br>
Унарная операция * означает
косвенное обращение: выражение
должно быть указателем и
результатом будет lvalue, ссылающееся
на объект, на который указывает
выражение. Если выражение имеет тип
&quot;указатель на ...&quot;, то тип
результата есть &quot;...&quot;. <br>
Результатом унарной операции &amp;
является указатель на объект, на
который ссылается операнд. Операнд
должен быть lvalue. Если выражение
имеет тип &quot;...&quot;, то тип
результата есть &quot;указатель на
...&quot;. <br>
Результатом унарной операции +
является значение ее операнда
после выполнения обычных
арифметических преобразований.
Операнд должен быть
арифметического типа. <br>
Результатом унарной операции -
является отрицательное значение ее
операнда. Операнд должен иметь
целый тип. Выполняются обычные
арифметические преобразования.
Отрицательное значение
беззнаковой величины вычисляется
посредством вычитания ее значения
из 2n, где n -число битов в целом типа
int. <br>
Результатом операции логического
отрицания ! является 1, если
значение операнда 0, и 0, если
значение операнда не 0. Результат
имеет тип int. Применима к любому
арифметическому типу или к
указателям. <br>
Операция ~ дает дополнение значения
операнда до единицы. Выполняются
обычные арифметические
преобразования. Операнд должен
иметь интегральный тип. </p>

<h4 align="center"><a name="ref1_7.7.2.1">7.2.1
Увеличение и Уменьшение </a></h4>

<p><a name="ref1_7.7.2.1">Операнд префиксного
++ получает приращение. Операнд
должен быть адресным . Значением
является новое значение операнда,
но оно не адресное. Выражение ++x
эквивалентно x+=1. По поводу данных о
преобразованиях см. обсуждение
операций сложения (</a><a href="#ref1_7.7.4">#7.4</a>)
и присваивания (<a href="#ref1_7.7.14">#7.14</a>). <br>
Операнд префиксного -- уменьшается
аналогично действию префиксной
операции ++. <br>
Значение, получаемое при
использовании постфиксного ++, есть
значение операнда. Операнд должен
быть адресным. После того, как
результат отмечен, объект
увеличивается так же, как и в
префиксной операции ++. Тип
результата тот же, что и тип
операнда. <br>
Значение, получаемое при
использовании постфиксной --, есть
значение операнда. Операнд должен
быть адресным. После того, как
результат отмечен, объект
увеличивается так же, как и в
префиксной операции ++. Тип
результата тот же, что и тип
операнда. </p>

<h4 align="center"><a name="ref1_7.7.2.2">7.2.2 Sizeof </a></h4>

<p><a name="ref1_7.7.2.2">Операция sizeof дает
размер операнда в байтах. (Байт не
определяется языком иначе, чем
через значение sizeof. Однако, во всех
существующих реализациях байт есть
пространство, необходимое для
хранения char.) При применении к
массиву результатом является
полное количество байтов в массиве.
Размер определяется из описаний
объектов, входящих в выражение.
Семантически это выражение
является беззнаковой константой и
может быть использовано в любом
месте, где требуется константа. <br>
Операцию sizeof можно также применять
к заключенному в скобки имени типа.
В этом случае она дает размер, в
байтах, объекта указанного типа. </a></p>

<h4 align="center"><a name="ref1_7.7.2.3">7.2.3 Явное
Преобразование Типа</a></h4>

<p><a name="ref1_7.7.2.3">Простое_имя_типа (</a><a
href="ref8.htm#ref8.2">#8.2</a>), возможно,
заключенное в скобки, за которым
идет заключенное в скобки
выражение (или список_выражений,
если тип является классом с
соответствующим образом описанным
конструктором <a href="ref8.htm#ref8.5.5">#8.5.5</a>)
влечет преобразование значения
выражения в названный тип. Чтобы
записать преобразование в тип, не
имеющий простого имени, имя_типа (<a
href="ref8.htm#ref8.7">#8.7</a>) должно быть
заключено в скобки. Если имя типа
заключено в скобки, выражение
заключать в скобки необязательно.
Такая запись называется
приведением к типу. <br>
Указатель может быть явно
преобразован к любому из
интегральных типов, достаточно по
величине для его хранения. То, какой
из int и long требуется, является
машинно зависимым. Отобразующая
функция также является машинно
зависимой, но предполагается, что
она не содержит сюрпризов для того,
кто знает структуру адресации в
машине. Подробности для некоторых
конкретных машин были приведены в <a
href="#ref1_7.2.6">#2.6.</a> <br>
Объект интегрального типа может
быть явно преобразован в указатель.
Отображающая функция всегда
превращает целое, полученное из
указателя, обратно в тот же
указатель, но в остальных случаях
является машинно зависимой. <br>
Указатель на один тип может быть
явно преобразован в указатель на
другой тип. Использование
полученного в результате указателя
может привести к исключительной
ситуации адресации, если исходный
указатель не указывает на объект,
соответствующим образом
выравненный в памяти.
Гарантируется, что указатель на
объект данного размера может быть
преобразован в указатель на объект
меньшего размера и обратно без
изменений. Различные машины могут
различаться по числу бит в
указателях и требованиям к
выравниванию объектов. Составные
объекты выравниваются по самой
строгой границе, требуемой
каким-либо из его составляющих. <br>
Объект может преобразовываться в
объект класса только если был
описан соответствующий
конструктор или операция
преобразования (<a href="ref8.htm#ref8.5.6">#8.5.6</a>).
<br>
Объект может явно
преобразовываться в ссылочный тип
&amp;X, если указатель на этот объект
может явно преобразовываться в X*. </p>

<h4 align="center"><a name="ref1_7.7.2.4">7.2.4
Свободная Память </a></h4>

<p><a name="ref1_7.7.2.4">Операция new создает
объект типа имя_типа (см. </a><a
href="ref8.htm#ref8.7">#8.7</a>), к которому он
применен. Время жизни объекта,
созданного с помощью new, не
ограничено областью видимости, в
которой он создан. Операция new
возвращает указатель на созданный
ей объект. Когда объект является
массивом, возвращается указатель
на его первый элемент. Например, и new
int и new int[10] возвращают int*. Для
объектов некоторых классов надо
предоставлять инициализатор (<a
href="ref8.htm#ref8.6.2">#8.6.2</a>). Операция new (<a
href="#ref1_7.7.2">#7.2</a>) для получения
памяти вызывает функцию </p>

<pre>
  void* operator new (long);
</pre>

<p><br>
Параметр задает требуемое число
байтов. Память будет
инициализирована. Если operator new() не
может найти требуемое количество
памяти, то она возвращает ноль. <br>
Операция delete уничтожает объект,
созданный операцией new. Ее
результат является void. Операнд delete
должен быть указателем,
возвращенным new. Результат
применения delete к указателю, который
не был получен с помощью операции
new. Однако уничтожение с помощью delete
указателя со значением ноль
безвредно. <br>
Чтобы освободить указанную память,
операция delete вызывает функцию </p>

<pre>
   void operator delete (void*);
</pre>

<p><br>
В форме </p>

<pre>
  delete [ выражение ] выражение
</pre>

<p><br>
второй параметр указывает на
вектор, а первое выражение задает
число элементов этого вектора.
Задание числа элементов является
избыточным за исключением случаев
уничтожения векторов некоторых
классов; см. <a href="ref8.htm#ref8.5.8">#8.5.8.</a> </p>

<h3 align="center"><a name="ref1_7.7.3">7.3
Мультипликативные операции </a></h3>

<p><a name="ref1_7.7.3">Мультипликативные
операции *, / и % группируют слева
направо. Выполняются обычные
арифметические преобразования. </a></p>

<p><a name="ref1_7.7.3">мультипликативное_выражение:
</a></p>

<pre><a name="ref1_7.7.3">
      выражение * выражение
      выражение  /  выражение
      выражение  % выражение
</a></pre>

<p><a name="ref1_7.7.3"><br>
Бинарная операция * определяет
умножение. Операция * ассоциативна
и выражения с несколькими
умножениями на одном уровне могут
быть реорганизованы компилятором. <br>
Бинарная операция / определяет
деление. При делении положительных
целых округление осуществляется в
сторону 0, но если какой-либо из
операндов отрицателен, то форма
округления является машинно
зависимой. На всех машинах,
охватываемых данным руководством,
остаток имеет тот же знак, что и
делимое. Всегда истинно, что (a/b)*b + a%b
равно a (если b не 0). <br>
Бинарная операция % дает остаток от
деления первого выражения на
второе. Выполняются обычные
арифметические преобразования.
Операнды не должны быть числами с
плавающей точкой. </a></p>

<h3 align="center"><a name="ref1_7.7.4">7.4 Аддитивные
операции </a></h3>

<p><a name="ref1_7.7.4">Аддитивные операции +
и - группируют слева направо.
Выполняются обычные
арифметические преобразования.
Каждая операция имеет некоторые
дополнительные возможности,
связанные с типами. </a></p>

<p><a name="ref1_7.7.4">аддитивное_выражение: </a></p>

<pre><a name="ref1_7.7.4">
      выражение + выражение
      выражение  -  выражение
</a></pre>

<p><a name="ref1_7.7.4"><br>
Результатом операции + является
сумма операндов. Можно суммировать
указатель на объект массива и
значение целого типа. Последнее во
всех случаях преобразуется к
смещению адреса с помощью
умножения его на длину объекта, на
который указывает указатель.
Результатом является указатель
того же типа, что и исходный
указатель, указывающий на другой
объект того же массива и
соответствующим образом смещенный
от первоначального объекта. Так,
если P есть указатель на объект
массива, то выражение P+1 есть
указатель на следующий объект
массива. <br>
Никакие другие комбинации типов
для указателей не допустимы. <br>
Операция + ассоциативна и выражение
с несколькими умножениями на одном
уровне может быть реорганизовано
компилятором. <br>
Результатом операции - является
разность операндов. Выполняются
обычные арифметические
преобразования. Кроме того,
значение любого целого типа может
вычитаться из указателя, в этом
случае применяются те же
преобразования, что и к сложению. <br>
Если вычитаются указатели на
объекты одного типа, то результат
преобразуется (посредством деления
на длину объекта) к целому,
представляющему собой число
объектов, разделяющих объекты,
указанные указателями. В
зависимости от машины
результирующее целое может быть
или типа int, или типа long; см. </a><a
href="#ref1_7.2.6">#2.6.</a> Вообще говоря, это
преобразование будет давать
неопределенный результат кроме тех
случаев, когда указатели указывают
на объекты одного массива,
поскольку указатели, даже на
объекты одинакового типа, не
обязательно различаются на
величину, кратную длине объекта. </p>

<h3 align="center"><a name="ref1_7.7.5">7.5 Операции
сдвига </a></h3>

<p><a name="ref1_7.7.5">Операции сдвига << и>&gt;
группируют слева направо. Обе
выполняют одно обычное
арифметическое преобразование над
своими операндами, каждый из
которых должен быть целым. В этом
случае правый операнд
преобразуется к типу int; тип
результата совпадает с типом
левого операнда. Результат не
определен, если правый операнд
отрицателен или больше или равен
длине объекта в битах. </a></p>

<p><a name="ref1_7.7.5">сдвиговое_выражение: </a></p>

<pre><a name="ref1_7.7.5">
          выражение                  << выражение выражение>&gt;                   выражение
</a></pre>

<p><a name="ref1_7.7.5"><br>
Значением Е1 << Е2 является Е1 (рассматриваемое как битовое представление), сдвинутое влево на Е2 битов; освободившиеся биты заполняются нулями. Значением Е1>&gt; Е2 является Е1 ,
сдвинутое вправо на Е2 битовых
позиций. Гарантируется, что сдвиг
вправо является логическим
(заполнение нулями), если Е1
является unsigned; в противном случае
он может быть арифметическим
(заполнение копией знакового бита). </a></p>

<h3 align="center"><a name="ref1_7.7.6">7.6 Операции
отношения </a></h3>

<p><a name="ref1_7.7.6">Операции отношения
(сравнения) группируют слева
направо, но этот факт не очень-то
полезен: a <b>выражение_отношения: </b></a></p>

<pre><a name="ref1_7.7.6"><b>
          выражение                   <выражение выражение>                   выражение
          выражение                  <= выражение выражение>=                  выражение
</b></a></pre>

<p><a name="ref1_7.7.6"><b><br>
Операции <(меньше чем),> (больше чем), <= и>= все дают 0,
если заданное соотношение ложно, и
1, если оно истинно. Тип результата
int. Выполняются обычные
арифметические преобразования.
Могут сравниваться два указателя;
результат зависит от
относительного положения объектов,
на которые указывают указатели, в
адресном пространстве. Сравнение
указателей переносимо только если
указатели указывают на объекты
одного массива. </b></a></p>

<h3 align="center"><a name="ref1_7.7.7"><b>7.7 Операции
равенства </b></a></h3>

<p><a name="ref1_7.7.7"><b>выражение_равенства:
</b></a></p>

<pre><a name="ref1_7.7.7"><b>
          выражение                   ==                  выражение
          выражение                   !=                   выражение
</b></a></pre>

<p><a name="ref1_7.7.7"><b><br>
Операции == и != в точности
аналогичны операциям сравнения за
исключением их низкого приоритета.
(Так, a </b></a></p>

<h3 align="center"><a name="ref1_7.7.8"><b>7.8 Операция
побитовое И </b></a></h3>

<p><a name="ref1_7.7.8"><b>И-выражение: </b></a></p>

<pre><a name="ref1_7.7.8"><b>
         выражение &amp; выражение
</b></a></pre>

<p><a name="ref1_7.7.8"><b><br>
Операция &amp; ассоциативна, и
выражения, содержащие &amp;, могут
реорганизовываться. Выполняются
обычные арифметические
преобразования; результатом
является побитовая функция И
операндов. Операция применяется
только к целым операндам. </b></a></p>

<h3 align="center"><a name="ref1_7.7.9"><b>7.9 Операция
побитовое исключающее ИЛИ </b></a></h3>

<p><a name="ref1_7.7.9"><b>исключающее_ИЛИ_выражение:
</b></a></p>

<pre><a name="ref1_7.7.9"><b>
          выражение ^ выражение
</b></a></pre>

<p><a name="ref1_7.7.9"><b><br>
Операция ^ ассоциативна, и
выражения, содержащие ^, могут
реорганизовываться. Выполняются
обычные арифметические
преобразования; результатом
является побитовая функция
исключающее ИЛИ операндов.
Операция применяется только к
целым операндам. </b></a></p>

<h3 align="center"><a name="ref1_7.7.10"><b>7.10 Операция
побитовое включающее ИЛИ </b></a></h3>

<p><a name="ref1_7.7.10"><b>включающее_ИЛИ_выражение:
</b></a></p>

<pre><a name="ref1_7.7.10"><b>
          выражение | выражение
</b></a></pre>

<p><a name="ref1_7.7.10"><b><br>
Операция | ассоциативна, и
выражения, содержащие |, могут
реорганизовываться. Выполняются
обычные арифметические
преобразования; результатом
является побитовая функция
включающее ИЛИ операндов. Операция
применяется только к целым
операндам. </b></a></p>

<h3 align="center"><a name="ref1_7.7.11"><b>7.11 Операция
логическое И </b></a></h3>

<p><a name="ref1_7.7.11"><b>логическое_И_выражение:
</b></a></p>

<pre><a name="ref1_7.7.11"><b>
          выражение &amp;&amp; выражение
</b></a></pre>

<p><a name="ref1_7.7.11"><b><br>
Операция &amp;&amp; группирует слева
направо. Она возвращает 1, если оба
операнда ненулевые, и 0 в противном
случае. В противоположность
операции &amp; операция &amp;&amp;
гарантирует вычисление слева
направо; более того, второй операнд
не вычисляется, если первый операнд
есть 0. <br>
Операнды не обязаны иметь один и
тот же тип, но каждый из них должен
иметь один из основных типов или
быть указателем. Результат всегда
имеет тип int. </b></a></p>

<h3 align="center"><a name="ref1_7.7.12"><b>7.12 Операция
логическое ИЛИ </b></a></h3>

<p><a name="ref1_7.7.12"><b>логическое_ИЛИ_выражение:
</b></a></p>

<pre><a name="ref1_7.7.12"><b>
          выражение || выражение
</b></a></pre>

<p><a name="ref1_7.7.12"><b><br>
Операция || группирует слева
направо. Она возвращает 1, если хотя
бы один из ее операндов ненулевой, и
0 в противном случае. В
противоположность операции |
операция || гарантирует вычисление
слева направо; более того, второй
операнд не вычисляется, если первый
операнд не есть 0. <br>
Операнды не обязаны иметь один и
тот же тип, но каждый из них должен
иметь один из основных типов или
быть указателем. Результат всегда
имеет тип int. </b></a></p>

<h3 align="center"><a name="ref1_7.7.13"><b>7.13 Условная
операция </b></a></h3>

<p><a name="ref1_7.7.13"><b>условное_выражение: </b></a></p>

<pre><a name="ref1_7.7.13"><b>
          выражение ? выражение : выражение
</b></a></pre>

<p><a name="ref1_7.7.13"><b><br>
Условная операция группирует слева
направо. Вычисляется первое
выражение, и если оно не 0, то
результатом является значение
второго выражения, в противном
случае значение третьего
выражения. Если это возможно, то
выполняются обычные
арифметические преобразования для
приведения второго и третьего
выражения к общему типу. Если это
возможно, то выполняются
преобразования указателей для
приведения второго и третьего
выражения к общему типу.
Вычисляется только одно из второго
и третьего выражений. </b></a></p>

<h3 align="center"><a name="ref1_7.7.14"><b>7.14 Операции
присваивания</b></a></h3>

<p><a name="ref1_7.7.14"><b>Есть много операций
присваивания, все группируют слева
направо. Все в качестве левого
операнда требуют lvalue, и тип
выражения присваивания тот же, что
и у его левого операнда. Это lvalue не
может ссылаться на константу (имя
массива, имя функции или const).
Значением является значение,
хранящееся в левом операнде просле
выполнения присваивания. </b></a></p>

<p><a name="ref1_7.7.14"><b>выражение_присваивания:
</b></a></p>

<pre><a name="ref1_7.7.14"><b>
      выражение  операция_присваивания  выражение
</b></a></pre>

<p><a name="ref1_7.7.14"><b>операция_присваивания:
одна из </b></a></p>

<pre><a name="ref1_7.7.14"><b>
      =  +=  -=  *=  /=  %=  &gt;&gt;=  <<= &="~=" |="&lt;/pre">

  В простом  присваивании с  = значение  выражения  замещает  собой
значение объекта,  на который ссылается операнд в левой части. Если
оба  операнда   имеют  арифметический  тип,  то  при  подготовке  к
присваиванию правый  операнд  преобразуется  к  типу  левого.  Если
аргумент в  левой части  имеет указательный  тип, аргумент в правой
части должен  быть  того  же  типа  или  типа,  кторый  может  быть
преобразован к  нему, см. </b></a><a
href="#ref1_7.6.7"><b> #6.7.</b></a><b> Оба  операнда могут быть объектами одного класса.  Могут присваиваться  объекты некоторых  производных
классов; см. </b><a href="ref8.htm#ref8.5.3"><b>#8.5.3.</b></a><b>

  Присваивание   объекту   типа   &quot;указатель   на   ...&quot;   выполнит
присваивание объекту, денотируемому ссылкой.

  Выполнение выражения  вида E1  op= E2  можно представить себе как
эквивалентное E1 = E1 op (E2); но E1 вычисляется только один раз. В
+= и  -= левый  операнд может  быть указателем,  и  в  этом  случае
(интегральный) правый  операнд преобразуется так, как объяснялось в
</b><a href="#ref1_7.7.4"><b>#7.4</b></a><b>; все  правые операнды и не являющиеся указателями левые должны иметь арифметический тип.
</b><a name="ref1_7.7.15"><b>
</b></a></pre>

<h3 align="center"><a name="ref1_7.7.15"><b>7.15 Операция
запятая </b></a></h3>

<p><a name="ref1_7.7.15"><b>запятая_выражение: </b></a></p>

<pre><a name="ref1_7.7.15"><b>
      выражение , выражение
</b></a></pre>

<pre><a name="ref1_7.7.15"><b>
  Пара выражений,  разделенных запятой,  вычисляется слева направо,
значение левого  выражения  теряется.  Тип  и  значение  результата
являются  типом   и  значением   правого  операнда.   Эта  операция
группирует  слева   направо.  В   контексте,  где   запятая   имеет
специальное значение,  как например в списке фактических параметров
функции  (</b></a><a href="#ref1_7.7.1"><b>#7.1</b></a><b>)    и  в  списке  инициализаторов  (</b><a
href="ref8.htm#ref8.6"><b>#8.6</b></a><b>),  операция запятая, как  она описана в этом разделе, может появляться только в скобках; например,
</b></pre>

<pre><b>
  f (a,(t=3,t+2),c)
</b></pre>

<pre><b>
имеет три параметра, вторым из которых является значение 5.
</b><a name="ref1_7.7.16"><b>
</b></a></pre>

<h3 align="center"><a name="ref1_7.7.16"><b>7.16
Перегруженные операции </b></a></h3>

<table border="0">
    <tr>
        <td width="10"><a name="ref1_7.7.16"><b></b></a>&nbsp;</td>
        <td><a href="#ref1_7.7.16.1"><b>7.16.1 Унарные
        операции </b></a></td>
    </tr>
    <tr>
        <td width="10"><b></b>&nbsp;</td>
        <td><a href="#ref1_7.7.16.2"><b>7.16.2 Бинарные
        операции</b></a><b> </b></td>
    </tr>
    <tr>
        <td width="10"><b></b>&nbsp;</td>
        <td><a href="#ref1_7.7.16.3"><b>7.16.3 Особые
        операции </b></a></td>
    </tr>
</table>

<p><b>Большинство операций может быть
перегружено, то есть, описано так,
чтобы они получали в качестве
операндов объекты классов (см. </b><a
href="ref8.htm#ref8.5.11"><b>#8.5.11</b></a><b>).
Изменить приоритет операций
невозможно. Невозможно изменить
смысл операций при применении их к
неклассовым объектам.
Предопределенный смысл операций = и
&amp; (унарной) при применении их к
объектам классов может быть
изменен. <br>
Эквивалентность операций,
применяемых к основным типам
(например, ++a эквивалентно a+=1), не
обязательно выполняется для
операций, применяемых к классовым
типам. Некоторые операции,
например, присваивание, в случае
применения к основным типам
требуют, чтобы операнд был lvalue; это
не требуется для операций,
описанных для классовых типов. </b></p>

<h4 align="center"><a name="ref1_7.7.16.1"><b>7.16.1
Унарные операции </b></a></h4>

<p><a name="ref1_7.7.16.1"><b>Унарная операция,
префиксная или постфиксная, может
быть определена или с помощью
функции члена (см. </b></a><a
href="ref8.htm#ref8.5.4"><b>#8.5.4</b></a><b>), не
получающей параметров, или с
помощью функции друга (см. </b><a
href="ref8.htm#ref8.5.10"><b>#8.5.10</b></a><b>),
получающей один параметр, но не
двумя способами одновременно. Так,
для любой унарной операции @, x@ и @x
могут интерпретироваться как
x.операция@() или операция@(x). При
перегрузке операций ++ и --
невозможно различить префиксное и
постфиксное использование. </b></p>

<h4 align="center"><a name="ref1_7.7.16.2"><b>7.16.2
Бинарные операции </b></a></h4>

<p><a name="ref1_7.7.16.2"><b>Бинарная операция
может быть определена или с помощью
функции члена (см. </b></a><a
href="ref8.htm#ref8.5.4"><b>#8.5.4</b></a><b>),
получающей один параметр, или с
помощью функции друга (см. </b><a
href="ref8.htm#ref8.5.9"><b>#8.5.9</b></a><b>),
получающей два параметра, но не
двумя способами одновременно. Так,
для любой бинарной операции @, x@y
может быть проинтерпретировано как
x.операция@(y) или операция@(x,y). </b></p>

<h4 align="center"><a name="ref1_7.7.16.3"><b>7.16.3 Особые
операции </b></a></h4>

<p><a name="ref1_7.7.16.3"><b>Вызов функции </b></a></p>

<pre><a name="ref1_7.7.16.3"><b>
  первичное_выражение ( список_выражений opt )
</b></a></pre>

<pre><a name="ref1_7.7.16.3"><b>
и индексирование
</b></a></pre>

<pre><a name="ref1_7.7.16.3"><b>
  первичное_выражение [ выражение ]
</b></a></pre>

<pre><a name="ref1_7.7.16.3"><b>
считаются  бинарными   операциями.  Именами   определяющей  функции
являются соответственно  operator()   и operator[]. Обращение x(arg)
интерпретируется как  x.operator()(arg) для  классового объекта  x.
Индексирование x[y] интерпретируется как x.operator[](y).
</b></a></pre>

<p><a name="ref1_7*1"><font size="2"><b>*</b><sup><b>1</b></sup><b>
&quot;Язык программирования Си&quot;
Брайэна В. Кернигана и Денниса М.
Ритчи. Это руководство было
построено на основе &quot;C Programming Language
- Reference Manual&quot; системы UNIX V с
разрешения AT&amp;T Bell Laboratories. (прим.
автора) </b></font></a><a name="ref1_7*2"><font size="2"><b><br>
*</b><sup><b>2</b></sup><b> !!! выделить
&quot;постоянной ширины&quot; шрифтом,
которым печатаются программы и
английские слова!!! </b></font></a><a
name="ref1_7*3"><font size="2"><b><br>
*</b><sup><b>3</b></sup><b> Этот термин
применяется для описания
использования в языке одной и той
же лексемы для обозначения
различных процедур; вид процедуры
выбирается компилятором на
основании дополнительной
информации в виде числа и типа
аргументов и т.п. </b></font></a></p>

<p align="center"><a name="ref1_7*3"><font size="2"><b>[</b></font></a><a
href="gl8.htm"><font size="2"><b>Назад</b></font></a><font
size="2"><b>] [</b></font><a href="ref.htm"><font size="2"><b>Содержание</b></font></a><font
size="2"><b>] [</b></font><a href="ref8.htm"><font size="2"><b>Вперед</b></font></a><font
size="2"><b>] </b></font></p>

<p align="center">&nbsp;</p>
</body>
</html>
